[
  {
    "id": 1,
    "title": "Inline Editor Test",
    "content": "This is the content of the post created aasdfasdfasdfusing the inline editor.",
    "tag": "Test",
    "summary": "Testing inline editor",
    "date": "2025-11-26",
    "password": "admin123"
  },
  {
    "id": 2,
    "title": "GPU-VOXELS 설치방법",
    "content": "### 1. 필요 라이브러리/ 드라이버 / 환경\n* Nvidia Graphic Driver\n* CUDA 10.0 버전 이상\n* cmake 최신버전\n* OpenNI2\n* PCL\n* ROS\n* BOOST\n* Ubuntu 16.04\n\n### 2. Nvidia Graphic Driver 설치\nhttps://www.nvidia.com/Download/Find.aspx?lang=en-us 에서 자신의 그래픽 카드 종류와 Ubuntu 버전에 알맞는 드라이버 파일('NVIDIA-Linux-x86_64-xxx.xxx.run') 다운로드.\n\n```shell\nsudo apt-get update\nsudo apt-get remove nvidia* && sudo apt autoremove \nsudo apt-get install dkms build-essential linux-headers-generic\nsudo gedit /etc/modprobe.d/blacklist.conf\n```\n\nblacklist.conf 파일을 열고 맨 아래에 다음을 추가한다.\n```\nblacklist nouveau\nblacklist lbm-nouveau\noptions nouveau modeset=0\nalias nouveau off\nalias lbm-nouveau off\n```\n\n```shell\necho options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf\nsudo update-initramfs -u\nsudo init 3\n```\n\ninit 3 명령을 통해 gui모드를 종료하고 cui모드로 전환 이후 ctrl + f2 키를 이용하여 창 전환\n이후 root계정으로 로그인.\n\n```shell\ncd /home/user/Downloads\nchmod 777 NVIDIA-Linux-x86_64-xxx.xxx.run\n./NVIDIA-Linux-x86_64-xxx.xxx.run\n\nsudo apt-get install dkms nvidia-modprobe\nsudo lspci - k\nnvidia-smi\n\n```\n### 3. ROS Kinetic 설치\n\nROS는 root 권한으로 설치 시 오류가 발생할 수 있으나 대부분 해결 가능한 경우이다. \nuser권한으로 설치 시 다양한 라이브러리들과의 결합 시 보다 심각한 오류가 발생할 수 있음.(root로 설치 하는 것을 추천)\n\n```shell\nwget https://raw.githubusercontent.com/ROBOTIS-GIT/robotis_tools/master/install_ros_kinetic.sh && chmod 755 ./install_ros_kinetic.sh && bash ./install_ros_kinetic.sh\n```\n\n```shell\nsudo apt-get install ros-kinetic-moveit ros-kinetic-industrial-core ros-kinetic-moveit-visual-tools ros-kinetic-joint-state-publisher-gui ros-kinetic-gazebo-ros-pkgs ros-kinetic-gazebo-ros-control ros-kinetic-joint-state-controller ros-kinetic-effort-controllers ros-kinetic-position-controllers ros-kinetic-joint-trajectory-controller\n```\nROS Melodic install\n```shell\nsudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list'\nsudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654\n\nsudo apt update\n\nsudo apt upgrade\n\nsudo apt install ros-melodic-desktop-full\n\n\nsudo apt-get install python-pip\n\nsudo pip install -U rosdep\n\nsudo rosdep init\n\nsudo rosdep update\n\necho \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc\nsource ~/.bashrc\n\nsudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential\n\ncd ~\n\nmkdir -p catkin_ws/src\ncd catkin_ws\ncatkin_make\n\n\n```\n\n### 한글 키보드 설치\n\n```shell\nsudo apt-get install fcitx-hangul\n```\n\n* `System Settings` -> `Language Support` \n* Language pack 설치\n* 'Keyboard input method system' -> `fcitx`로 변경\n* reboot\n\n* `System Settings`-> `Keyboard` -> `Shortcuts` ->`Typing` \n* (`Switch to next source`, `Switch to previous source`, `Alternative Characters Key`)-> `Disabled`로 설정\n* `Compose Key` -> `Right Alt`로 변경\n* `Switch to next source`->  `Multikey`\n\n<br>\n\n#### fcitx 설정\n\n* `fcitx`  → `Configure Current Input Method` 선택\n*  `Only Show Current Language` 체크 버튼 해제 -> `+` 버튼 ->  `Hangul` 추가\n* `Global Config` 탭  `Trigger Input Method` -> `Multikey`\n* `Extra key for trigger input method`-> `Disabled`\n\n\n#### 18.04 한글키보드\n\nhttps://gabii.tistory.com/entry/Ubuntu-1804-LTS-%ED%95%9C%EA%B8%80-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%84%A4%EC%A0%95\n\n#### 18.04 한글 키\n\nhttps://hanmaruj.tistory.com/6\n\n### 4. CUDA 설치\nhttps://developer.nvidia.com/cuda-10.0-download-archive 에서 Ubuntu 16.04의 Cuda 설치파일 다운\n\nhttps://developer.nvidia.com/cuda-10.1-download-archive-base?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1804&target_type=deblocal\n\nsudo apt update\nsudo add-apt-repository ppa:graphics-driverssudo apt-key adv --fetch-keys  http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pubsudo bash -c 'echo \"deb http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64 /\" > /etc/apt/sources.list.d/cuda.list'sudo bash -c 'echo \"deb http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1804/x86_64 /\" > /etc/apt/sources.list.d/cuda_learn.list'\n\nsudo apt update\nsudo apt install cuda-10-1\n\n```shell\nsudo init 3\n```\n\nctrl+f2를 이용해 cui모드 전환\n```shell\ncd /home/user/Downloads\nchmod 777 cuda_10.0.130_410.48_linux.run\n./cuda_10.0.130_410.48_linux.run\n```\n설치 중 Nvidia Driver 설치는 No를 하고 다른 사항은 모두 Yes\n```shell\ngedit ~/.bashrc\n```\n다음의 내용을 맨 아래에 추가\n\n    export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH\n    export PATH=/usr/local/cuda/bin:$PATH\n    \n    \n다시 터미널에서 다음과 같이 입력\n\n\n```shell\nsource ~/.bashrc\nnvcc --version\n```\n\n\n결과가 다음과 같이 나와야한다.\n\n\n\n```shell\nnvcc: NVIDIA (R) Cuda compiler driver\nCopyright (c) 2005-2018 NVIDIA Corporation\nBuilt on Sat_Aug_25_21:08:01_CDT_2018\nCuda compilation tools, release 10.0, V10.0.130\n```\n\n### 5. cmake 최신버전 설치\n\n```shell\napt-get install libssl-dev\nwget https://cmake.org/files/v3.18/cmake-3.18.0.tar.gz\ntar -zxvf cmake-3.18.0.tar.gz\ncd cmake-3.18.0\n./bootstrap\nmake\nmake install\n```\n### 6.Eigen 설치\n\n```shell\nmv /usr/include/eigen3/Eigen /usr/include/eigen3/Eigen_backup\n```\ninstall eigen 3.3.9\n```shell\n  wget https://gitlab.com/libeigen/eigen/-/archive/3.3.9/eigen-3.3.9.tar.gz\n  tar xvf eigen-3.3.9.tar.gz\n  cd eigen-3.3.9\n  make -j16\n  make install\n```\n\n\n\n### 7. Boost 1.58 버전 설치\n\nubuntu 16.04에서만 설치.\n\n\n```shell\nwget https://sourceforge.net/projects/boost/files/boost/1.58.0/boost_1_58_0.tar.gz\ntar -zxvf boost_1_58_0.tar.gz\ncd boost_1_58_0\nsudo bash bootstrap.sh\n./b2\n./b2 install\n```\n\n\n\n### 8. VTK 8.2 설치\n\n```shell\nsudo apt-get install libgl1-mesa-dev\nsudo apt-get install libxt-dev \nwget https://www.vtk.org/files/release/8.2/VTK-8.2.0.tar.gz\ntar -zxvf VTK-8.2.0.tar.gz\ncd VTK-8.2.0\nmkdir build\ncd build\ncmake ..\nmake -j16\nmake install\n```\n\n\n### 9. OpenNI2 설치\n\n```shell\nsudo apt-get install git\ngit clone https://github.com/occipital/OpenNI2.git\ncd OpenNI2\nsudo apt-get install g++\nsudo apt-get install libusb-1.0-0-dev\nsudo apt-get install libudev-dev\nsudo apt-get install cmake libx11-dev xorg-dev libglu1-mesa-dev freeglut3-dev libglew1.5 libglew1.5-dev libglu1-mesa libglu1-mesa-dev libgl1-mesa-glx libgl1-mesa-dev libglfw3-dev libglfw3\napt-get install openjdk-8-jre\napt-get install openjdk-8-jdk\nsudo apt-get install graphviz\n\nsudo rm /usr/lib/x86_64-linux-gnu/libGL.so\nsudo ln -s /usr/lib/libGL.so.1 /usr/lib/x86_64-linux-gnu/libGL.so\n\nsudo rm -r /usr/lib/x86_64-linux-gnu/libEGL.so\nsudo ln -s /usr/lib/x86_64-linux-gnu/libEGL.so.1 /usr/lib/x86_64-linux-gnu/libEGL.so\n\nmake -j16\n\nsudo ln -s $PWD/Bin/x64-Release/libOpenNI2.so /usr/local/lib/\nsudo ln -s $PWD/Bin/x64-Release/OpenNI2/ /usr/local/lib/ \nsudo ln -s $PWD/Include /usr/local/include/OpenNI2\nldconfig\ncd Bin/x64-Release/\n./SimpleRead\n```\n\n### 10. PCL 1.9.1 설치\n\n```shell\n\nsudo apt-get install libeigen3-dev\napt-get install libflann-dev\n\nsudo apt-get install g++ cmake cmake-gui doxygen mpi-default-dev openmpi-bin openmpi-common libeigen3-dev libboost-all-dev libqhull* libusb-dev libgtest-dev git-core freeglut3-dev pkg-config build-essential libxmu-dev libxi-dev libusb-1.0-0-dev graphviz mono-complete qt-sdk libeigen3-dev\nsudo apt install libglew-dev\nsudo apt-get install libsqlite3-0 libpcap0.8  \nsudo apt-get install libpcap-dev\n\nwget https://github.com/PointCloudLibrary/pcl/archive/pcl-1.9.1.tar.gz\ntar xvf pcl-1.9.1.tar.gz\n\ncd pcl-pcl-1.9.1\nmkdir build\ncd build\ncmake ..\nmake -j16\nmake install\n```\n+ 주의) cmake-gui를 이용하여 with openni2를 설정해서 build해야 gpu-voxel 설치시 openni-grubber.h 오류가 발생하지 않는다.\n\n### 11. OROCOS_KDL install( if you want)\n\n```shell\n\ngit clone https://github.com/orocos/orocos_kinematics_dynamics.git\ncd  orocos_kinematics_dynamics\nmkdir build\ncd build\ncmake ..\nmake -j16\nmake install\n\n```\n\n\n\n### 12. GPU-VOXELS 설치\n\n```shell\napt-get install cmake-qt-gui\napt-get install libglew-dev\napt-get install libglm-dev\nsudo apt-get install qt5-default\nsudo rm /usr/lib/x86_64-linux-gnu/libGL.so\nsudo ln -s /usr/lib/libGL.so.1 /usr/lib/x86_64-linux-gnu/libGL.so\n```\nUbuntu 16.04\n```shell\ngit clone https://github.com/fzi-forschungszentrum-informatik/gpu-voxels.git\n```\nUbuntu 18.04\n```shell\ngit clone https://github.com/fzi-forschungszentrum-informatik/gpu-voxels.git\n```\n```shell\ncd gpu-voxels/\nmkdir build\ncd build/\ncmake ..\ncmake-gui ..\n```\n\n\nkdl_parser_DIR  = /opt/ros/kinetic/share/kdl_parser/cmake\n\norocos_kdl_DIR = /opt/ros/kinetic/share/orocos_kdl\n\n\nENABLE_CUDA에 체크되어있는지 확인\n\n![1](https://user-images.githubusercontent.com/53217819/93412302-ddbc8c80-f8d7-11ea-85c3-43837a1a6b4b.png)\n\nGLM_INCLUDE_DIR이 설정되어 있는지 확인\n\n![2](https://user-images.githubusercontent.com/53217819/93412308-e319d700-f8d7-11ea-9400-83eaf178fae7.png)\n\n```shell\nexport GPU_VOXELS_MODEL_PATH=/home/sung/workspace/gpu-voxels/packages/gpu_voxels/models/\n\n```\n\n\n\n### 13. 추가 명령어\n\n```shell\n ./urdf_loader_ros_listener -r -135 -p 0 -y 90\n  ./distance_ros_demo-r -135 -p 0 -y 90\n \n```\n### 13. installation guides\nhttps://github.com/roboticslab-uc3m/installation-guides\n\n\n\n### librealsense install\n16.04\n```shell\nsudo apt-key adv --keyserver keys.gnupg.net --recv-key F6E65AC044F831AC80A06380C8B3A55A6F3EFCDE || sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key F6E65AC044F831AC80A06380C8B3A55A6F3EFCDE In case the public key still cannot be retrieved, check and specify proxy settings: export http_proxy=\"http://<proxy>:<port>\"\n```\nUbuntu 16 LTS:\n```shell\nsudo add-apt-repository \"deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo xenial main\" -u\n```\nUbuntu 18 LTS:\n```shell\nsudo add-apt-repository \"deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo bionic main\" -u\n```\n\n```shell\nsudo apt-get install librealsense2 librealsense2-dkms librealsense2-utils librealsense2-dev librealsense2-dbg\n\n```\n\n```shell\ngit clone https://github.com/IntelRealSense/librealsense.git\ncd librealsense\nmkdir build\ncd build \ncmake ..\nmake -j16\nmake install\n```\n\n```shell\nsudo apt-get install ros-kinetic-ddynamic-reconfigure\n\ncd ~/catkin_ws/src\ngit clone https://github.com/IntelRealSense/realsense-ros.git\ncd ../../\ncatkin_make \n```\n### Azure Kinect install\n```shell\ncurl -sSL https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -\n\nsudo apt-add-repository https://packages.microsoft.com/ubuntu/18.04/prod\n\nsudo apt-get update\n\nsudo apt install k4a-tools\n\nsudo apt install libk4a1.4\n\nsudo apt install libk4a1.4-dev\n\ncd ~/catkin_ws/src\n\ngit clone https://github.com/microsoft/Azure_Kinect_ROS_Driver.git\n\ncd ../\n\ncatkin_make\n\n```\n\n### indy-ros\n```shell\napt-get install ros-kinetic-industrial-robot-client\ncd ~/catkin_ws/src && git clone -b release-2.3 https://github.com/neuromeka-robotics/indy-ros\ncd ~/catkin_ws/src && git clone https://github.com/neuromeka-robotics/indy-ros-examples\ncd ~/catkin_ws\ncatkin_make\n```\n### ros start\n```shell\nroslaunch indy_driver_py indy7_moveit_dcp.launch robot_ip:=192.168.0.7 robot_name:=NRMK-Indy7\n```\n\n ```shell\n roslaunch realsense2_camera demo_pointcloud.launch\n ```\n\nhttps://ropiens.tistory.com/30\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 3,
    "title": "libpointmatcher 설치방법",
    "content": "### 수정사항\n\n```bash\ngedit build/examples/CMakeFiles/icp_simple.dir/link.txt\n```\n```bash\n -o icp_simple\n ```\n 를 지우고 아래 코드로 변경\n ```bash\n-shared -o icp_simple.so\n```\n\n\n```bash\ngedit build/examples/CMakeFiles/icp_simple.dir/flags.make\n```\n```bash\nCXX_FLAGS = -O3 -DNDEBUG   -fPIC -O3 -Wall -std=gnu++11\n```\n\n위의 부분을 다음과 같이 변경\n```bash\nCXX_FLAGS = -O3 -DNDEBUG   -O3 -Wall -std=gnu++11\n```\n빌드 후 example/icp_simple.so가 생성되었는지 확인\n\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 4,
    "title": "Homework 1",
    "content": "### Kane's Method의 특성\n1. 벡터기반(vector-based) 방법으로 3D 분석에 용이\n2. Vector cross product와 dot product를 적극적으로 활용\n3. Generalized force를 이용하여 운동 방정식 기술\n4. Generalized inertia force ${F}^{*}_{r}$\n5. D'Alembert Principle에 의해 $F_r + F^*_r = 0$\n6. 수식을 간단하게 하기위해 generalized speed, partial velocity, partial angular velocity 활용\n7. non contributing force와 torque를 무시\n\n### Solve 1.5 and compare the results of Kane's method? What is the reason why the answers are different between Kane's method and Newton-Euler method?\n\nfree body diagram으로 나타내면\n\n![그림3](https://user-images.githubusercontent.com/53217819/95018597-c0d7d580-069b-11eb-83c4-731701cc5739.png)\n\n### Vector Kinematics\n1. Ground reference frame을 $(N)$ 이라 하고 좌표계는 $(\\hat{n_{1}},\\hat{n_{2}},\\hat{n_{3}})$\n2. Link $A$ body frame을 $(A)$ 이라 하고 좌표계는 $(\\hat{a_{1}},\\hat{a_{2}},\\hat{a_{3}})$\n3. Link $B$ body frame을 $(B)$ 이라 하고 좌표계는 $(\\hat{b_{1}},\\hat{b_{2}},\\hat{b_{3}})$\n4. 각 축 각도 : $q_{1}, q_{2}$\n5. $N$에서 $A$로 작용하는 토크 $\\vec{\\tau}_{N/A}$\n6. $A$에서 $B$로 작용하는 토크 $\\vec{\\tau}_{A/B}$\n7. $\\vec{F}$는 링크 끝단에 작용하는 external force\n8. Direction cosine table\n![캡처](https://user-images.githubusercontent.com/53217819/95019024-11e8c900-069e-11eb-9a8e-3efd3c4e773e.PNG)\n$c_i = \\cos{q_i}$ , $s_i = \\sin{q_i}$, $c_{12} = \\cos{(q_1+q_2)}$, $s_{12} = \\sin{(q_1+q_2)}$\n9. 각속도와 각가속도\n   * $N$ 프레임과 $A$ 프레임 사이의 각속도는 $q_{1}$의 변화량이다. $\\hat{a}_3$은 회전방향의 normal vector이다.\n   \n       ${}^{N}\\vec{\\omega}{}^{A} = \\dot{q_1}\\hat{a}_3$\n       \n   * $N$ 프레임과 $A$ 프레임 사이의 각가속도는 $\\dot{q}_{1}$의 변화량이다. $\\hat{a}_3$은 회전방향의 normal vector이다.\n   \n       ${}^{N}\\vec{\\alpha}{}^{A} = \\ddot{q}_{1}\\hat{a}_3$\n       \n   * $N$ 프레임과 $B$ 프레임 사이의 각속도는 $q_1$과 $q_2$의 합의 변화량이다. $\\hat{b}_3$은 회전방향의 normal vector이다.\n   \n       ${}^{N}\\vec{\\omega}{}^{B} = (\\dot{q}_{1}+\\dot{q}_2)\\hat{b}_3$\n       \n   * $N$ 프레임과 $B$ 프레임 사이의 각가속도는 $\\dot{q}_1$과 $\\dot{q}_2$의 합의 변화량이다. $\\hat{a}_3$은 회전방향의 normal vector이다.\n   \n       ${}^{N}\\vec{\\alpha}{}^{B} = (\\ddot{q}_1+\\ddot{q}_2)\\hat{b}_3$\n10. 특정 포인트에 대한 (선)속도와 (선)가속도\n    * $A_0$에서의 속도와 가속도\n   \n        ${}^{N}\\vec{v}{}^{A_0} = 0$\n       \n        ${}^{N}\\vec{a}{}^{A_0} = 0$\n       \n    * $A^{*}$(A링크의 무게중심)에서의 속도와 가속도\n   \n        ${}^{N}\\vec{v}{}^{A^{* }} = \\rho_{A} \\dot{q}_1 \\hat{a}_2 $\n       \n        ${}^{N}\\vec{a}{}^{A^{* }} = \\frac{d}{dt}({}^{N}\\vec{v}{}^{A^{* }}) $\n       \n        $=\\rho_{A} \\frac{d}{dt}( \\dot q_1 ) \\hat a_2 +\\rho_{A} \\dot q_1 \\frac{d}{dt}( \\hat a_2 )$\n       \n        $=\\rho_{A}\\ddot q_1\\hat a_2+\\rho_{A}\\dot q_1({}^{N}\\vec{\\omega}{}^{A}\\times \\hat a_2)$\n       \n        $=-\\rho_{A} \\dot q_{1}^2 \\hat a_1+\\rho_{A} \\ddot q_1 \\hat a_2 $\n       \n       \n       \n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 5,
    "title": "GPU-Voxels Example 생성",
    "content": "### Cmake 설정\n기존 예제 폴더 내의 CMakeLists.txt 파일을 새로 만든 예제 폴더에 옮기고 수정한다.\n\n```bash\nmkdir smc_example\ncd smc_example\ncp ../example_how_to_link/CMakeLists.txt .\ncp ../example_how_to_link/gvl_linkage* .\ncp gvl_linkage_test.cpp smc_example.cpp\ngedit CMakeLists.txt\n```\nCMakeLists.txt 파일에서 build할 파일 이름을 수정한다.\n```bash\n# this is for emacs file handling -*- mode: cmake; indent-tabs-mode: nil -*-\n\n# ======================================\n# CMakeLists file to demonstrate how to use GPU Voxels in your own project:\n# ======================================\n\ncmake_minimum_required (VERSION 2.8)\nproject (gvl_linkage_test)\n\n# First we have to find our dependencies:\nFIND_PACKAGE(CUDA REQUIRED)\nFIND_PACKAGE(icl_core REQUIRED )\nFIND_PACKAGE(gpu_voxels REQUIRED)\nFIND_PACKAGE(Boost COMPONENTS system REQUIRED)\n\n# This is a quirk and should be removed in upcoming versions\n# If you built GPU Voxels without ROS support, remove this.\nFIND_PACKAGE(orocos_kdl REQUIRED)\n\n# A little debug info:\nMESSAGE(STATUS \"GVL include dirs are: ${gpu_voxels_INCLUDE_DIRS}\")\n\n# Also we have to inherit some Environment definitions required for our base libs:\nadd_definitions(\n  ${icl_core_DEFINITIONS}\n  ${gpu_voxels_DEFINITIONS}\n)\n\n\n# Create a library that uses GPU Voxels:\nadd_library (gvl_linkage_test_lib gvl_linkage_test_lib.cpp)\n\ntarget_include_directories (gvl_linkage_test_lib\n    PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}\n    PUBLIC ${gpu_voxels_INCLUDE_DIRS}\n    PUBLIC ${orocos_kdl_INCLUDE_DIRS} # this should be removed in upcoming versions.\n    PUBLIC ${CUDA_INCLUDE_DIRS}\n)\n\n# Add an executable that calls the lib:\nadd_executable (smc_example smc_example.cpp)\n\n# Link the executable to the library.\n# We currently also have to link against Boost and icl_core...\ntarget_link_libraries (smc_example\n    LINK_PUBLIC gvl_linkage_test_lib\n    LINK_PUBLIC ${Boost_SYSTEM_LIBRARY}\n    LINK_PUBLIC ${icl_core_LIBRARIES}\n    LINK_PUBLIC ${gpu_voxels_LIBRARIES}\n    LINK_PUBLIC ${CUDA_LIBRARIES}\n)\n\n\n```\n\ncmake-gui를 이용하여 gpu-voxelx와, icl-cores가 빌드된 폴더를 정한다.\n\n```bash\n\ncmake-gui .\n```\n\n\n![Screenshot from 2020-09-25 15-28-45](https://user-images.githubusercontent.com/53217819/94234047-ddf60100-ff43-11ea-87d8-f059118e3f9d.png)\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 6,
    "title": "GPU-Voxels Open Motion Planning Library Example 생성",
    "content": "이 포스트에서는 뉴로메카사의 Indy7을 이용하여 GPU-Voxels 라이브러리를 활용한 Motion Planning 예제를 만든다.\n예제를 실행하기 전 GPU-Voxels를 완전하게 설치해야 한다.\n### Indy7-description을 다운로드\n먼저 neuromeka github에서 indy7의 로봇 모델 파일을 받는다.\n```bash\ngit clone https://github.com/neuromeka-robotics/indy-ros\n```\n\n### gvl_ompl_planning example build\ngpu-voxles 폴더에 있는 gvl_ompl_planning을 build한다.\nbuild를 성공하기 위해서는 먼저 ros가 설치되어 있으며 ros ompl을 설치해야 한다.\n```bash\napt-get install ros-kinetic-ompl\ncmake-gui .\n```\ncmake-gui를 통해 library의 설치여부를 확인한다.\n![Screenshot from 2020-09-29 19-43-06](https://user-images.githubusercontent.com/53217819/94548717-18d19f00-028c-11eb-8ab5-044c2fad5efb.png)\n\n위와같이 gpu_voxels_DIR, icl_core_DIR을 gpu-voxels build폴더 내에서 선택해야한다.\n\n정확하게 설정되어 있을 경우 configure과 generate를 누른다.\n이후 cmake-gui를 나온 후 make를 이용하여 빌드한다.\n```bash\nmake -j16\n./gvl_ompl_planner\n```\n생성된 gvl_ompl_planner을 실행하면 다음과 같이 나온다. \n```bash\n<2020-09-29 19:48:06.825> CudaLog(Info)::cuTestAndInitDevice: Running on GPU 0 (GeForce RTX 2080 Ti)\n<2020-09-29 19:48:07.013> RobotLog(Info) Robot::RobotToGPU: Parsing URDF /home/sung/workspace/gpu-voxels/packages/gpu_voxels/models/indy7_coarse/indy7.urdf\n<2020-09-29 19:48:07.021> RobotLog(Info) Robot::load: Constructed KDL tree has 6 Joints and 8 segments.\nName of shared buffer swapped: voxel_list_buffer_swapped_1.\nInfo:    LBKPIECE1: Attempting to use default projection.\nDebug:   LBKPIECE1: Planner range detected to be 2.879317\nWaiting for Viz. Press Key if ready!\n```\n이제 다른 터미널 창에서 gpu-voxels의 build폴더에서 bin폴더에 위치한 gpu_voxels_visualizer를 실행한다.\n```bash\ncd /home/sung/workspace/gpu-voxels/build/bin\n./gpu_voxels_visualizer\n```\n![Screenshot from 2020-09-29 19-52-43](https://user-images.githubusercontent.com/53217819/94549545-5aaf1500-028d-11eb-8efb-b2195f97eaae.png)\n\ngpu_voxels_visualizer가 실행된 후에 gvl_ompl_planning 터미널에서 Enter를 누르면 example이 실행된다.\n\n![Screenshot from 2020-09-29 19-54-24](https://user-images.githubusercontent.com/53217819/94549714-9944cf80-028d-11eb-802f-ca3ea17cf53c.png)\n\n### Indy7 urdf 적용하기\n미리 수정된 indy7 urdf파일을 다운 받는다.\n```bash\ncd /home/sung/workspace/gpu-voxels/packages/gpu_voxels/models\ngit clone https://github.com/tjdalsckd/gpu-voxels-indy7\n```\n\n```bash\ngedit /home/sung/workspace/gpu-voxels/gvl_ompl_planning/gvl_ompl_planner_helper.cpp\n```\n60번째 줄을 다음과 같이 변경한다.\n```bash\nline 60:     gvl->addRobot(\"myUrdfRobot\", \"indy7_coarse/indy7.urdf\", true);\n```\n\n```bash\ncd /home/sung/workspace/gpu-voxels/gvl_ompl_planning\nmake -j16\n```\n### constraint 변경\n\n```bash\ngedit /home/sung/workspace/gpu-voxels/gvl_ompl_planning/gvl_ompl_planner_helper.cpp\n```\ngvl_ompl_planner_helper.cpp 파일에서 85부터 87줄은 박스 형태의 Constraint를 추가하는 부분이다.\n박스의 시작점과 끝점을 Vector3f로 입력하여 추가할 수 있다.\n\n```bash\nline 85:    gvl->insertBoxIntoMap(Vector3f(1.0,1.0,0.0), Vector3f(1.2,1.2,1.2), \"myEnvironmentMap\", eBVM_OCCUPIED, 2);\nline 86:    gvl->insertBoxIntoMap(Vector3f(1.8,1.8,0.0), Vector3f(2.0,2.0,1.2), \"myEnvironmentMap\", eBVM_OCCUPIED, 2);\nline 87:    gvl->insertBoxIntoMap(Vector3f(0.0,0.0,0.0), Vector3f(3.0,3.0,0.01), \"myEnvironmentMap\", eBVM_OCCUPIED, 2);\n```\n### goal joint position 변경\n목표 joint 각도 변경은 gvl_ompl_planner.cpp파일에서 수정할 수 있다.\n\n```bash\ngedit /home/sung/workspace/gpu-voxels/gvl_ompl_planning/gvl_ompl_planner.cpp\n```\n\n```bash\nline 85:    goal[0] = 3.141592/2;\nline 86:    goal[1] = -0.5;\nline 87:    goal[2] = 0.0;\nline 88:    goal[3] = 0.0;\nline 89:    goal[4] = 0.0;\nline 90:    goal[5] = 0.0;\n```\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 7,
    "title": "GPU-Voxels Realsense Indy7 연동",
    "content": "### terminator를 이용하여 여러개의 터미널 세팅\n```shell\nsudo apt-get install terminator\nsu sung\ngedit ~/.config/terminator/config\n\n[global_config]\n[keybindings]\n[profiles]\n  [[default]]\n    cursor_color = \"#aaaaaa\"\n  [[New Profile]]\n    cursor_color = \"#aaaaaa\"\n[layouts]\n  [[default]]\n    [[[child0]]]\n      type = Window\n      parent = \"\"\n      order = 0\n      position = 0:27\n      maximised = False\n      fullscreen = False\n      size = 574, 974\n      title = sung@sung: ~\n      last_active_term = 0b2f2b78-0ca5-4a59-8383-499cac1571ee\n      last_active_window = True\n    [[[child1]]]\n      type = VPaned\n      parent = child0\n      order = 0\n      position = 484\n      ratio = 0.49948400412796695\n    [[[child2]]]\n      type = VPaned\n      parent = child1\n      order = 0\n      position = 237\n      ratio = 0.49478079331941544\n    [[[terminal3]]]\n      type = Terminal\n      parent = child2\n      order = 0\n      profile = New Profile\n      uuid = 0b2f2b78-0ca5-4a59-8383-499cac1571ee\n      command = echo 'sy3253' | sudo -S su -c whoami; clear;sudo -S su root\n    [[[terminal4]]]\n      type = Terminal\n      parent = child2\n      order = 1\n      profile = default\n      uuid = e6a2ccfd-e5a3-4f2e-868a-44bb28da7f4f\n      command = echo 'sy3253' | sudo -S su -c whoami; clear;sudo -S su root\n    [[[child5]]]\n      type = VPaned\n      parent = child1\n      order = 1\n      position = 240\n      ratio = 0.49586776859504134\n    [[[terminal6]]]\n      type = Terminal\n      parent = child5\n      order = 0\n      profile = default\n      uuid = d23c7307-6a52-49fd-8524-05aa201c030b\n      command = echo 'sy3253' | sudo -S su -c whoami; clear;sudo -S su root\n    [[[terminal7]]]\n      type = Terminal\n      parent = child5\n      order = 1\n      profile = default\n      uuid = 2637f0ac-8d18-4a3b-a62a-ec7062e6585d\n      command = echo 'sy3253' | sudo -S su -c whoami; clear;sudo -S su root\n  [[New Layout]]\n    [[[child0]]]\n      type = Window\n      parent = \"\"\n      order = 0\n      position = 0:27\n      maximised = False\n      fullscreen = False\n      size = 574, 974\n      title = sung@sung: ~\n      last_active_term = 0b2f2b78-0ca5-4a59-8383-499cac1571ee\n      last_active_window = True\n    [[[child1]]]\n      type = VPaned\n      parent = child0\n      order = 0\n      position = 484\n      ratio = 0.49948400412796695\n    [[[child2]]]\n      type = VPaned\n      parent = child1\n      order = 0\n      position = 237\n      ratio = 0.49478079331941544\n    [[[terminal3]]]\n      type = Terminal\n      parent = child2\n      order = 0\n      profile = New Profile\n      uuid = 0b2f2b78-0ca5-4a59-8383-499cac1571ee\n      command = su root;sy3253\n    [[[terminal4]]]\n      type = Terminal\n      parent = child2\n      order = 1\n      profile = default\n      uuid = e6a2ccfd-e5a3-4f2e-868a-44bb28da7f4f\n      command = su root;sy3253\n    [[[child5]]]\n      type = VPaned\n      parent = child1\n      order = 1\n      position = 240\n      ratio = 0.49586776859504134\n    [[[terminal6]]]\n      type = Terminal\n      parent = child5\n      order = 0\n      profile = default\n      uuid = d23c7307-6a52-49fd-8524-05aa201c030b\n      command = su root;sy3253\n    [[[terminal7]]]\n      type = Terminal\n      parent = child5\n      order = 1\n      profile = default\n      uuid = 2637f0ac-8d18-4a3b-a62a-ec7062e6585d\n      command = su root;sy3253\n[plugins]\n    \n    \n\n```\n수평 분할 ctrl+shift+O\n수직 분할 ctrl+shift+t\n\n#### terminal 1\n\n```shell\nroslaunch realsense2_camera demo_pointcloud.launch\n```\n\n#### terminal 2\n\n```shell\nroslaunch indy_driver_py indy7_moveit_dcp.launch robot_ip:=192.168.0.7 robot_name:=NRMK-Indy7\n```\n\n#### terminal 3\n\n```shell\ncd workspace/gpu-voxels/build/bin/\nexport GPU_VOXELS_MODEL_PATH=/home/sung/workspace/gpu-voxels/packages/gpu_voxels/models/\n./distance_ros_demo -r -135 -p 0 -y 90\n```\n\n#### terminal 4\n\n```shell\ncd workspace/gpu-voxels/build/bin/\nexport GPU_VOXELS_MODEL_PATH=/home/sung/workspace/gpu-voxels/packages/gpu_voxels/models/\n./gpu_voxels_visualizer\n```\n![Screenshot from 2020-11-04 20-29-06](https://user-images.githubusercontent.com/53217819/98106218-805aba00-1edc-11eb-8748-ff70a703018f.png)\n\n![Screenshot from 2020-11-04 20-29-25](https://user-images.githubusercontent.com/53217819/98106225-82247d80-1edc-11eb-82f0-df80183c5cdb.png)\n\n\n#### indy c++ build\ng++ -std=c++11 -o test.out test_smc.cpp IndyDCP.cpp IndyDCPConnector.cpp IndyDCPException.cpp\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 8,
    "title": "Grasp quality measures: review and performance",
    "content": "## Grasp quality measures: review and performance\n### 1. Grasp과 Grasp Planning이란?\n본 논문은 Autonomous Robots에 2014년 실린 저널로 Grasp Quality Measure에 대한 리뷰 페이퍼이다.\n\nGrasp의 목표는 외부에서 작용하는 Disturbance(물체 자체 무게를 포함) 하에서 어떤 물체에 제약조건을 거는 것이다. \n\nGrasp Planning은 적절한 그리퍼 선택과, 그 그리퍼를 이용하여 물체와의 Contact Point를 결정하는 것을 말한다.\n\n### 2. 일반적인 Grasp Planning 방식\nGrasp Planning은 크게 두 가지 방식으로 나뉜다. 먼저 Empirical grasp 방식은 여러가지 방법들을 통해 Grasp에 성공하는 적절한 Contact point(또는 Hand Configuration)을 학습하고 결정한다. Neural Network를 이용한 학습, Fuzzy logic, Knowledge-based systems 등이 있다.\n\n다른 방식은 Analytic한 방식으로 물체와 Hand 사이의 Interaction을 수학적인 모델을 세워 분석하는 방식이다. 2D polygonal을 이용한 해석, 3D polyhedral Objects를 이용한 해석 등이 있다.\n\n### 3. Grasp Synthesis Algorithm의 특성\n#### * Disturbance resistance\nGrasp은 어떠한 방향에서 오는 Disturbance더라도 견뎌내야 한다. 즉 물체의 Immobility가 보장되어야만 한다.(Form closure, Force Closure)\n#### * Dexterity\nHand를 이용하여 물체를 작업이 가능하도록 움직인다면 이를 Dextrous하다 라고 한다.\n#### * Equilibrium\nGrasp이 Equilibrium하다는 것은 물체에 가해지는 토크나 힘의 결과가 없는 경우를 의미한다.\n#### * Stability\nDisturbance에 의한 Object Position Error가 시간에 지남에 따라 사라지는 것을 Stable하다 한다.\n\n### 4. Basic background and nomenclature\n접촉점에 작용하는 force는 물체에 대해서만 작용할 수 있다.(positivity constraint), 그리고 fingertip과 물체 사이의 접촉은 다음과 같다.\n#### Punctual contact without friction\n마찰이 없는 표면에 가해지는 force는 정확히 접촉 점 경계의 normal 벡터이다.\n#### Punctual contact with friction(hand contact)\n마찰이 있는 경우는 여러가지 모델로 표현이 가능하지만 주로 쓰이는 것은 Coulomb's friciotn cone 방식이다.\n#### Soft Contact\n3D 물체에서만 가능한 분석으로 접촉 점에서 force 뿐만아니라 접촉 점 경계에서의 torque까지를 포함한 분석이다.\n![그림1](https://user-images.githubusercontent.com/53217819/98537729-0c9a2200-22cd-11eb-9adf-350aac2c558a.png)\n\n각 접촉점에 적용되는 wrenches의 indepedent components의 숫자를 $r$ 이라 했을 때에 $r = 1$일 때는 마찰이 없는 접촉, $r = 2$일 때는 마찰이 존재하는 2D 접촉, $r= 3$일 때는 마찰이 존재하는 3D 접촉, $r = 4$일 때는 soft contact이다.\n\n물체에 작용하는 torque 는 $\\tau_i = p_i \\times F_i$ 이며 물체의 center of mass을 기준으로 작용한다. 이 때의 force 와 torqure를 묶어서 wrench vector $\\omega_i = (F_i,\\tau_i/\\rho)^T$로 나타낸다. $\\rho$는 wrench space의 metric이며 constant로 정의된다. $\\rho$는 물체의 회전반경과 CM으로부터의 가장 먼 물체 표면의 점으로 기술된다. wrench vector의 dimension은 2D의 경우 $d = 3$, 3D의 경우 $d = 6 $이다.\n\nCM에서의 선속도와 회전 속도를 twist라고 부르며 다음과 같이 나타낸다. $\\dot{x} = (v,w)^T $ twist는 2D의 경우 $R^3$ 3D의 경우 $R^6$에 속한다.\n\n각 finger의 joint에 작용하는 토크는 다음과 같이 표기한다.\n$T = [ T _ { 1 j } ^ { T } \\ldots T _ { n j } ^ { T } ] ^ { T } \\in R ^ { n m }$\n\n![그림2](https://user-images.githubusercontent.com/53217819/98538175-b679ae80-22cd-11eb-8993-c9aec3b116cd.png)\n\ni개의 fingertip에서의 contact force 는 $f_i$ 로 표기하며 마찰력이 있는 경우 contact force component는 다음과 같이 표기한다.\n\n$f = [ f _ { 1 k } ^ { T } \\ldots f _ { n k } ^ { T } ] ^ { T } \\in R ^ { n r } ( k = 1 , \\ldots , r )$\n\ni개의 fingertip에서의 contact point들의 velocity component는 다음과 같이 표기한다.\n\n$\\nu = [ \\nu _ { 1 k } ^ { T } \\ldots \\nu _ { n k } ^ { T } ] ^ { T } \\in R ^ { n r }$\n\n![그림3](https://user-images.githubusercontent.com/53217819/98540689-ab288200-22d1-11eb-84cc-ccb5d96eb8f9.png)\n\n### 5. Grasp Matrix $G$\n\n![그림4](https://user-images.githubusercontent.com/53217819/98540105-c1820e00-22d0-11eb-9781-5609de7effd3.png)\n\n#### Contact Jacobian\n\nJoint velocity로부터 Contact Points의 velocity로 변환해주는 Jacobian\n\n\n$v = J _ { h } \\dot { \\theta } $\n\n\n$J _ { h } = \\operatorname { diag } [ J _ { 1 } , \\ldots , J _ { i } ] \\in R ^ { n r \\times n m }$\n\n#### Grasp Matrix $G$\n\nObject의 Twist로부터 Contact Points의 Velocity로 변환해주는 Jacobian $G^T$\n\n\n$nu = G ^ { T } \\dot { x }$\n\n\n$G \\in R ^ { d \\times n r }$\n\ndd\n\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 9,
    "title": "GPU-VOXELS 충돌파악",
    "content": "https://github.com/tjdalsckd/gpu-voxel-collision\n\n\n### gvl_ompl_planner를 이용한 충돌 파악\n대략적인 코드진행은 다음과 같다.\n\n  1. gvl_ompl_planner의 코드는 gvl_ompl_planner_helper.cpp 코드의 GvlOmplPlannerHelper 클래스에서 모션플래닝 관련 내용이 선언되고 동작한다.\n\n  2. ros callback을 이용해 realsense pointcloud 데이터를 받고 이를 화면에 출력한다.\n\n  3. ros callback을 이용해 현재 jointState를 받는다.\n\n  4. pointcloud 데이터를 myEnvironmentMap으로 설정한다.\n\n  5. ompl을 이용해 로봇이 움직일 경로인 solutionMap을 획득한다.\n\n  6. solutionMap과 myEnvironmentMap 각각에서 현재 로봇과 교차하는 부분을 계산한다.\n\n  7. 각각의 교차부분을 빼서 실제 물체와 solutionMap과의 교차 부분을 계산한다.\n\n![ezgif com-gif-maker (2)](https://user-images.githubusercontent.com/53217819/101426825-10a77700-3941-11eb-8ccf-c9c17f696b29.gif)\n\n### collision 개수 파악\n\nnum_colls는 모션플래닝으로 획득한 solution map과 realsense를 이용한 countingVoxelList의 교차를 파악해 개수를 얻는다.\nnum_colls2는 로봇과 countingVoxellist와의 교차를 파악하고 개수를 얻는다.\n이 둘의 차가 증가했을 경우 충돌로 파악하고 프린트한다.\n```javascript {.line-numbers}\nwhile(ros::ok()){\n      ros::spinOnce();\n      \n      if (new_data_received) \n      {\n           new_data_received = false;\n           iteration++;\n\n           pbaDistanceVoxmap->clearMap();\n      \n           countingVoxelList->clearMap();\n           countingVoxelListFiltered->clearMap();\n           erodeTempVoxmap1->clearMap();\n           erodeTempVoxmap2->clearMap();\n           countingVoxelList->insertPointCloud(my_point_cloud, eBVM_OCCUPIED);\n           gvl->visualizeMap(\"countingVoxelList\");\n           num_colls = gvl->getMap(\"countingVoxelList\")->as<gpu_voxels::voxellist::CountingVoxelList>()->collideWith(gvl->getMap(\"mySolutionMap\")->as<gpu_voxels::voxellist::BitVectorVoxelList>(), 1.0f);\n           num_colls2 = gvl->getMap(\"countingVoxelList\")->as<gpu_voxels::voxellist::CountingVoxelList>()->collideWith(gvl->getMap(\"myRobotMap\")->as<gpu_voxels::voxellist::BitVectorVoxelList>(), 1.0f); \n           if(num_colls-num_colls2>=180)\n                 std::cout << \"!!!!!!!!!!!!!!!Detected Collision!!!!!!!!! \" << num_colls-num_colls2 << \" collisions \" << std::endl;\n           \n      }\n      r.sleep();\n    }\n```\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 10,
    "title": "Indy7 Control matlab 코드",
    "content": "https://github.com/tjdalsckd/indy7_matlab\n\n\n\n```bash\nclc; clear;\nthetalist = [0;pi/2;0;0;0;0];\ndthetalist = [0.1; 0.2; 0.3;0.1;0.1;0.1];\n%Initialize robot description (Example with 3 links)\nH1 = 0.3;\nH2 = 0.45;\nH3 = 0.350;\nH4 = 0.228;\nW1 = 0.0035;\nW2 = 0.183;\nS1 = [0; 0;  1;  0; 0;  0];\nS2 =        [0; -1;  0; H1;0 ;  0];\nS3 =        [0; -1;  0; H1+H2; 0; 0];\nS4 =        [0; 0;   1; -W1; 0; 0];\nS5 =        [0; -1;  0; H1+H2+H3; 0; 0];\nS6 =        [0; 0;  1; -W1-W2;0; 0];\nM01 = [1 0 0 0;...\n       0 1 0 0;\n       0 0 1 H1;\n       0 0 0 1]\nM12 = [0  -1   0   0;...\n      0   0   -1   0;...\n      1   0    0   0;\n      0   0    0   1 ];\nM23 = [0 -1 0 H2;...\n       1 0 0 0;...\n       0 0 1 0;\n       0 0 0 1 ];\nM34 = [-1 0  0 0;...\n       0 0  -1 -H3;...\n       0 -1 0 W1;...\n       0 0 0 1 ];\nM45 = [1 0 0 0;...\n      0  0 -1 -W2 ;...\n      0  1 0 0;...\n      0  0 0 1 ];\nM56 = [1 0 0 0;...\n      0 0 1 H4;...\n      0 -1 0 0;...\n      0 0 0 1 ];\n\n  \nI0 = Inertia_matrix(0.00572623,0.00558989,0.00966674,0.00000251,-0.0000014,-0.00011380);\nI1 = Inertia_matrix(0.15418559,0.12937017,0.05964415,-0.00000235,-0.04854267,0.00001739);\nI2 = Inertia_matrix(0.2935698,0.28094142,0.03620609,-0.0000004,0.03727972,0.00001441);\nI3 = Inertia_matrix(0.03424593,0.03406024,0.00450477,0.00000149,0.00186009,0.00000724);\nI4 = Inertia_matrix(0.00670405,0.00279246,0.00619341,0.00000375,-0.00127967,0.0000015);\nI5 = Inertia_matrix(0.00994891,0.00978189,0.00271492,0.00000014,-0.00093546,0.00000321);\nI6 = Inertia_matrix(0.00043534,0.00044549,0.00059634,0.00000013,0.00000051,-0.00000002);\nmass0 = 1.59306955;\nmass1 = 11.8030102;\nmass2 = 7.99292141;\nmass3 = 2.99134127;\nmass4 = 2.12317035;\nmass5 = 2.28865091;\nmass6 = 0.40083918;\n\n\nG1 = eye(6)*mass1;\nG1(1:3,1:3) = I1;\nG2 = eye(6)*mass2;\nG2(1:3,1:3) = I2;\nG3 = eye(6)*mass3;\nG3(1:3,1:3) = I3;\nG4 = eye(6)*mass4;\nG4(1:3,1:3) = I4;\nG5 = eye(6)*mass5;\nG5(1:3,1:3) = I5;\nG6 = eye(6)*mass6;\nG6(1:3,1:3) = I6;\nGlist = cat(3, G1, G2, G3,G4,G5,G6);\nMlist = cat(3, eye(4),M01, M12, M23, M34,M45,M56);\nSlist = [S1,S2,S3,S4,S5,S6];\ng = [0; 0; -9.8];\ndt = 0.01;\n%Create a trajectory to follow\nthetaend =[ 0; 0;0;0;0;0];\nTf = 1;\nN = Tf / dt;\nmethod = 5;\nthetamatd = JointTrajectory(thetalist, thetaend, Tf, N, method);\ndthetamatd = zeros(N, 6);\nddthetamatd = zeros(N, 6);\ndt = Tf / (N - 1);\nfor i = 1: N - 1\n  dthetamatd(i + 1, :) = (thetamatd(i + 1, :) - thetamatd(i, :)) / dt;\n  ddthetamatd(i + 1, :) = (dthetamatd(i + 1, :) ...\n                          - dthetamatd(i, :)) / dt;\nend\n\nFtipmat = zeros(N, 6);\nKp = 100;\nKi = 100;\nKd = 10;\nintRes = 8;\n[taumat, thetamat] ...\n= SimulateControl(thetalist, dthetalist, g, Ftipmat, Mlist, Glist, ...\n                Slist, thetamatd, dthetamatd, ddthetamatd, g, ...\n                Mlist, Glist, Kp, Ki, Kd, dt, intRes);\n\ndthetalist = [0 0 0 0 0 0]';      \nFtip = [ 0 0 0 0 0 0]';\nshow_mesh = 1;\nfv0 = stlread('mesh/Indy7_0.stl');\nfv1 = stlread('mesh/Indy7_1.stl');\nfv2 = stlread('mesh/Indy7_2.stl');\nfv3 = stlread('mesh/Indy7_3.stl');    \nfv4 = stlread('mesh/Indy7_4.stl');   \nfv5 = stlread('mesh/Indy7_5.stl');\nfv6 = stlread('mesh/Indy7_6.stl');   \nv = VideoWriter('newfile.avi','Motion JPEG AVI');\nv.Quality = 100;\nopen(v)\nfigure('Renderer', 'painters', 'Position', [0 0 1920 1080])\nfor i = 1:1:100\ntaulist = taumat(i,:);\nthetalist = thetamat(i,:);\nddthetalist = ForwardDynamics(thetalist, dthetalist, taulist, g, ...\n                             Ftip, Mlist, Glist, Slist);\ndthetalist  = dthetalist+ddthetalist*dt;                         \n\nsubplot(1,2,1)\n\ndrawrobot(thetalist',show_mesh,fv0,fv1,fv2,fv3,fv4,fv5,fv6);\ntitle('D-H parameter')\nsubplot(1,2,2)\n\ndrawrobot_screw(thetalist',show_mesh,fv0,fv1,fv2,fv3,fv4,fv5,fv6);\n\ntitle('PoE')\nframe = getframe(gcf);\n   writeVideo(v,frame);\nend\nclose(v);\n```\n\n\n![ezgif com-gif-maker (1)](https://user-images.githubusercontent.com/53217819/102008522-9c236c80-3d74-11eb-8cdf-ecf0cf1d97ce.gif)\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 11,
    "title": "Inverse Jacobian을 이용한 Obstacle Avoidance Trajectory 생성 matlab 코드",
    "content": "https://github.com/tjdalsckd/ModernRobotics_Obstacle_Avoidance_example/\n\n\n\n```bash\naddpath('mr')\nclear\nclose all;\nL1 = 1;\nL2 = 1;\nL3 = 1;\nL4 = 1;\nL5 = 1;\nL6 = 1;\nL7 = 1;\nL8 = 1;\n\nS1 = [0 0 1 0 0 0]';\nS2 = [0 0 1 0 -L1 0]';\nS3 = [0 0 1 0 -L1-L2 0]';\nS4 = [0 0 1 0 -L1-L2-L3 0]';\nS5 = [0 0 1 0 -L1-L2-L3-L4 0]';\nS6 = [0 0 1 0 -L1-L2-L3-L4-L5 0]';\nS7 = [0 0 1 0 -L1-L2-L3-L4-L5-L6 0]';\nS8 = [0 0 1 0 -L1-L2-L3-L4-L5-L6-L7 0]';\n\n\nM = [1 0 0 L1+L2+L3+L4+L5+L6+L7+L8;...\n    0 1 0 0;...\n    0 0 1 0;...\n    0 0 0 1];\n\nM09 = [1 0 0 L1+L2+L3+L4+L5+L6+L7+L8;...\n    0 1 0 0 ;...\n    0 0 1 0;...\n    0 0 0 1 ];\n\nM08 = [1 0 0 L1+L2+L3+L4+L5+L6+L7;...\n    0 1 0 0 ;...\n    0 0 1 0;...\n    0 0 0 1 ];\n\nM07 = [1 0 0 L1+L2+L3+L4+L5+L6;...\n    0 1 0 0 ;...\n    0 0 1 0;...\n    0 0 0 1 ];\n\nM06 = [1 0 0 L1+L2+L3+L4+L5;...\n    0 1 0 0 ;...\n    0 0 1 0;...\n    0 0 0 1 ];\n\nM05 = [1 0 0 L1+L2+L3+L4;...\n    0 1 0 0 ;...\n    0 0 1 0;...\n    0 0 0 1 ];\n\nM04 = [1 0 0 L1+L2+L3;...\n    0 1 0 0 ;...\n    0 0 1 0;...\n    0 0 0 1 ];\n\nM03 = [1 0 0 L1+L2;...\n    0 1 0 0 ;...\n    0 0 1 0;...\n    0 0 0 1 ];\n\n\nM02 = [1 0 0 L1;...\n    0 1 0 0 ;...\n    0 0 1 0;...\n    0 0 0 1 ];\n\nM01 = eye(4);\n\n\n\nSlist = [S1,S2,S3,S4,S5,S6,S7,S8];\nthetastart = [pi/2,pi/2,0,pi/2,0,-pi/2,-pi/2,pi/2]';\n\nmatS1 = MatrixExp6(VecTose3(S1)*thetastart(1));\nmatS2 = MatrixExp6(VecTose3(S2)*thetastart(2));\nmatS3 = MatrixExp6(VecTose3(S3)*thetastart(3));\nmatS4 = MatrixExp6(VecTose3(S4)*thetastart(4));\nmatS5 = MatrixExp6(VecTose3(S5)*thetastart(5));\nmatS6 = MatrixExp6(VecTose3(S6)*thetastart(6));\nmatS7 = MatrixExp6(VecTose3(S7)*thetastart(7));\nmatS8 = MatrixExp6(VecTose3(S8)*thetastart(8));\n\nT_start = matS1*matS2*matS3*matS4*matS5*matS6*matS7*matS8*M;\nT_end = [-1 0 0 -5; 0 -1 0 0; 0 0 1 0; 0 0 0 1];\n\nTf = 1\nN = 100\ndt = Tf/N;\ntraj = CartesianTrajectory(T_start, T_end, Tf, N, 5)\n\nstart_p = [-4,0,0];\nend_p = [-6,0,0];\ntraj_w=cubic_polynomials(0,-pi/2,Tf,N);\ntraj_x=cubic_polynomials(start_p(1),end_p(1),Tf,N);\ntraj_y=cubic_polynomials(start_p(2),end_p(2),Tf,N);\ntraj_z=cubic_polynomials(start_p(3),end_p(3),Tf,N);\n\ntrajV = zeros(N,6);\ntrajV(:,3) =0;\ntrajV(:,4) = traj_x;\ntrajV(:,5) = traj_y;\ntrajV(:,6) = traj_z;\n\nTwist = trajV\nthetalist = thetastart;\nx_obstacle_ = linspace(-4,-3,100);\ny_obstacle_ = linspace(2,1,100);\nz_obstacle_ = linspace(1,0,100) ;\nradius =1.8;\nMlist = {M02,M03,M04,M05,M06,M07,M08,M09}\n% \n% v = VideoWriter('newfile.avi','Motion JPEG AVI');\n% v.Quality = 100;\n% open(v)\n% figure('Renderer', 'painters', 'Position', [0 0 1920 1080])\n\nfor i = 1:1:100\n    x_obstacle = x_obstacle_(i)\n    y_obstacle = y_obstacle_(i)\n    z_obstacle = z_obstacle_(i)\n    \n    Js = JacobianSpace(Slist, thetalist');\n    [dist,px,py,pz] = distanceJoint(Mlist,Slist,thetalist,x_obstacle,y_obstacle,z_obstacle);\n    [min_dist,min_dist_ind] = min(dist);\n    psuedo_Js = pinv(Js);\n    J0 = Js(4:end,:);\n    J0(:,10-min_dist_ind+1:end) = 0;\n\n    ObTwist = 1/min_dist.^2*[(px(min_dist_ind)-x_obstacle)/(abs(px(min_dist_ind)-x_obstacle)+0.0001) (py(min_dist_ind)-y_obstacle)/(abs(py(min_dist_ind)-y_obstacle)+0.0001) (pz(min_dist_ind)-z_obstacle)/(abs(pz(min_dist_ind)-z_obstacle)+0.0001) ]';\n    alpha_0 = 1;\n    alpha_eta = 1;\n    if min_dist >radius*2\n         dthetalist  = psuedo_Js*Twist(i,:)';\n         \n    else\n        dthetalist  = psuedo_Js*Twist(i,:)'+5*(eye(8)-psuedo_Js*Js)*pinv(J0)*(10*ObTwist-J0*psuedo_Js*Twist(i,:)');\n%           dthetalist  = psuedo_Js*Twist(i,:)'+30*(eye(8)-psuedo_Js*Js)*pinv(J0)*ObTwist;\n    end\n    thetalist = thetalist + dthetalist*dt;\n    drawrobot(M,Slist,thetalist);\n\n    \n    draswobstacle(x_obstacle,y_obstacle,z_obstacle,radius);\n%     frame = getframe(gcf);\n%    writeVideo(v,frame);\n\n    hold off;\nend\n% close(v);\n\n```\n![ezgif com-gif-maker (5)](https://user-images.githubusercontent.com/53217819/102484872-36075400-40aa-11eb-9178-222ed005c758.gif)\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 12,
    "title": "Pybullet을 이용한 Two link robot PD control",
    "content": "무게나 inertia를 고려하지 않은 단순 위치기반 토크 제어 코드입니다.\n\n\n```bash\nimport pybullet as p\nimport time\nimport pybullet_data\nimport numpy as np\nimport math\n\n\n## setup\nuseMaximalCoordinates = False\np.connect(p.GUI)\np.setGravity(0, 0, -10)\np.setAdditionalSearchPath(pybullet_data.getDataPath())\n\npole = p.loadURDF(\"twolink_robot/twolink.urdf\", [0, 0, 0], useMaximalCoordinates=useMaximalCoordinates)\np.resetBasePositionAndOrientation(pole, [0, 0, 0], [0, 0, 0, 1])\n\np.setJointMotorControl2(pole, 0, p.POSITION_CONTROL, targetPosition=0, force=0)\np.setJointMotorControl2(pole, 1, p.POSITION_CONTROL, targetPosition=0, force=0)\ntimeStepId = p.addUserDebugParameter(\"timeStep\", 0.001, 0.1, 0.01)\nuseRealTimeSim = False\np.setRealTimeSimulation(useRealTimeSim)\n\n\nnumJoints = p.getNumJoints(pole)\n\ndesired_q = np.array([0,0]);\ndesired_qdot = np.array([0,0]);\nkpCart = 500\nkdCart = 150\nkpPole = 500\nkdPole = 150\nprev_q = 0\n\nkps = [kpCart, kpPole]\nkds = [kdCart, kdPole]\nmaxF = np.array([100,100]);\n\n\nwhile p.isConnected():\n\ttimeStep = p.readUserDebugParameter(timeStepId)\n\tp.setTimeStep(timeStep)\n\tjointStates = p.getJointStates(pole,[0,1])\n\tq = np.array([jointStates[0][0],jointStates[1][0]])\n\tqdot = np.array((q-prev_q )/timeStep)\n\n\n###       CONTROL LOOP\n\tqError = desired_q - q;\n\tqdotError = desired_qdot - qdot;\n\tKp = np.diagflat(kps)\n\tKd = np.diagflat(kds)\n\ttorques = Kp.dot(qError)+Kd.dot(qdotError)\n\t\n\ttorques = np.clip(torques,-maxF,maxF)\n\tprev_q = q\n\n###\t\n\n\n\tp.setJointMotorControlArray(pole, [0,1], controlMode=p.TORQUE_CONTROL, forces=torques)\n\t\n\tif (not useRealTimeSim):\n\t\tp.stepSimulation()\n\t\ttime.sleep(timeStep)\n```\n![Screenshot from 2021-03-10 20-54-59](https://user-images.githubusercontent.com/53217819/110625562-ed5fc280-81e2-11eb-870c-7bf2f35de5d7.png)\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 13,
    "title": "image2latex mathpix ",
    "content": "mathpix라는 이미지의 수식을 latex로 변환해주는 프로그램의 api를 사용한 python 프로그램입니다.\n\n\n\nhttps://github.com/tjdalsckd/image2latex_mathpix\n\n\n# EXE 실행방법\nmathpix api를 사용하여 screenshot을 찍고 latex 문법으로 변형해주는 프로그램입니다.\n\n먼저 API를 사용하기위한 ID와 KEY가 필요합니다.\n\nhttps://mathpix.com/ 에 가입 후 \n\nMy account에서 Get API Keys에 들어가서 Accept 클릭,\n\n다음 화면에서 결제 카드를 입력합니다.\n\nAPI 사용료는 1000회 이상 이용부터 1회당 0.004 달러 결제됩니다.\n\n![캡ddd처](https://user-images.githubusercontent.com/53217819/91630925-a1042080-ea10-11ea-9dfb-5d07f791b349.PNG)\n\n카드 입력 후 API ID와 API KEY를 확인합니다.\n\n![캡dsdsdsd처](https://user-images.githubusercontent.com/53217819/91630926-a2354d80-ea10-11ea-86b9-4e21a836368c.PNG)\n\n\napp.json파일을 열어 API ID와 API KEY를 입력합니다\n\n\n![image](https://user-images.githubusercontent.com/53217819/147766301-6b8c62a7-97ab-428a-b72b-77caf6bdd371.png)\n\n\n압축을 풀고 폴더에 app.json파일을 옮깁니다.\n\n![image](https://user-images.githubusercontent.com/53217819/147766360-6f32492f-a929-42c2-9b1d-0311a1168fe7.png)\n\n\nmain.exe 프로그램을 실행합니다. 다음과 같이 나오면 성공, 프로그램이 꺼지면 app.json파일을 다시 확인해주세요\n\n![image](https://user-images.githubusercontent.com/53217819/147766480-4e1cda97-1415-4012-b2b2-7ce0e01f9578.png)\n\n캡처 도구를 열고 변환하고 싶은 곳을 캡처하면 다음과 같이 표시됩니다.\n\n![image](https://user-images.githubusercontent.com/53217819/147766639-23cb7624-1920-4c08-ad03-17435d2a94bb.png)\n\nCtrl+Shift+A를 누르면 변환이 수행된 후 Clipboard에 복사됩니다.\n\n![image](https://user-images.githubusercontent.com/53217819/147766823-9a005719-f98f-40e8-ae58-0c4ba0c7e3c4.png)\n\n\n\n\n# SOURCE CODE 실행방법\n```bash\npip install keyboard pyperclip pillow\npython main.py\n ```\n \n or\n ```bash\npip3 install keyboard pyperclip pillow\npython3 main.py\n```\n\n\n\n\n\n\n# EXE 변환방법\n```bash\npyinstaller --onfile  --nowindowed main.py\n```\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 14,
    "title": "SublimeText3 with MikTex ",
    "content": "# sublimetext_latex_-\n\n## Sublime Text install\nhttps://www.sublimetext.com/3\nWindows 64bit 선택(OS에 맞는 버전 선택 )\n![image](https://user-images.githubusercontent.com/53217819/147725460-a333b986-149e-4ab1-9456-a3203663e15e.png)\n다운로드 후 설치 진행 Next\n![image](https://user-images.githubusercontent.com/53217819/147725515-926ef88c-8cdd-4079-8a76-eca5dc5f312d.png)\nInstall\n![image](https://user-images.githubusercontent.com/53217819/147725531-f8e30749-6858-4094-8dfd-c6be65ae2c28.png)\n\n## install Miktex\nhttps://miktex.org/download\n![image](https://user-images.githubusercontent.com/53217819/147725733-c6da59d9-3005-4c77-9006-3170f4aed9f9.png)\n\n다운로드 후 실행하고 Next누르고 Install\n\n## install SumatraPDF\nhttps://www.sumatrapdfreader.org/download-free-pdf-viewer\n\n![image](https://user-images.githubusercontent.com/53217819/147725768-515c8d5e-da8e-491c-afca-79103503f2e7.png)\n\n![image](https://user-images.githubusercontent.com/53217819/147726018-c5db3033-81db-41f3-bee4-9f62066aeaaa.png)\n\n![image](https://user-images.githubusercontent.com/53217819/147726030-37d85879-dfec-453c-92f9-264bc04f7a6d.png)\n옵션에서 설치폴더 변경 C드라이브의 Program Files로 \n\n![image](https://user-images.githubusercontent.com/53217819/147726056-ae44bcec-c7de-4035-894c-9d1f12f0d3de.png)\n\n\n시스템 환경변수 등록\n\n시스템 속성에서 환경 변수 클릭\n\n![image](https://user-images.githubusercontent.com/53217819/147725904-555701b4-3c86-482e-845c-baefc1336c71.png)\n\n000에 대한 사용자 변수 탭에서 Path누르고 편집 클릭\n\n![image](https://user-images.githubusercontent.com/53217819/147725919-488e81ea-f72b-4a46-abba-03fb01487aa4.png)\n\n찾아보기를 누르고 SumatraPDF가 설치된 폴더를 찾아서 입력(C:\\Program Files\\SumatraPDF)\n\n![image](https://user-images.githubusercontent.com/53217819/147726108-a16a0870-694d-4bc3-abed-ff018a3ea6d6.png)\n\n\n\n## install Package Control \nSublime Text 3 를 켜고 Ctrl+Shift+P 를누르면 창이 열린다.\n![image](https://user-images.githubusercontent.com/53217819/147725659-3f32d171-32b1-4c99-b8a9-dd54a94bce22.png)\n\ninstall control package를 입력하고 설치 진행\n\n![image](https://user-images.githubusercontent.com/53217819/147725798-a5d4b044-7bf0-4991-9acf-8a197481ca04.png)\n![image](https://user-images.githubusercontent.com/53217819/147725812-8ee112a8-e184-432e-b864-0204b6f476e1.png)\n![image](https://user-images.githubusercontent.com/53217819/147725874-8e8a6600-d467-485a-b403-186985c1dcf6.png)\n![image](https://user-images.githubusercontent.com/53217819/147725876-47c2cdee-1479-407c-9e6d-526e8a6648e5.png)\n\n다음과 같이 나오면 성공\n![image](https://user-images.githubusercontent.com/53217819/147725882-ded14faa-0ae3-462a-8881-38c9f5fa909f.png)\n\n## 사용법\nCtrl+B를 누르면 빌드 자동으로 파일이 나옴\n![image](https://user-images.githubusercontent.com/53217819/147726201-cff16b80-05bd-4de7-b51d-01ef1ba1622e.png)\n\n\n\n\n\n\n\n## ERROR\n\n### nanummjmd4 에러 발생 시 일단 재부팅 해보고 아래 진행\n\n시작->MikTex Console 실행\n\n![image](https://user-images.githubusercontent.com/53217819/152146968-44c43b3e-cae2-46d9-be56-ef02f7798d05.png)\n\nSwitch to MikTex administrator mode 선택\n재시작 후에 Updates 클릭\n\n![image](https://user-images.githubusercontent.com/53217819/152147075-a595a644-b08f-420f-9c08-b91544c91f5a.png)\n\nCheck for updates 클릭 Update now 클릭 \nSublimeText3 다시 실행-> 빌드 진행\n\n이래도 안된다면 재부팅 후 다시진행\n\n\n\n\n## 참고 사이트\nhttps://pinkwink.kr/853\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 15,
    "title": "Windows11에서 WSL을 이용하여 ROS설치하기 ",
    "content": "+ windows 10 최신업데이트버전 설치\n https://github.com/AveYo/MediaCreationTool.bat\n\n\n1.windows 11설치\n - pc 상태검사 앱 다운로드 후 상태확인\n```bash\nhttps://aka.ms/GetPCHealthCheckApp\n```\n - 윈도우 11 installer 다운로드 후 설치\n ```bash\n https://go.microsoft.com/fwlink/?linkid=2171764\n ```\n2. windows 11 설치 후 wsl을 이용하여 터미널 창 실행\n![image](https://user-images.githubusercontent.com/53217819/138554378-6c74bb31-b25d-43f3-aba6-d176dc62e9af.png)\n\n3. NVIDIA 드라이버 및 CUDA 설치 방법\n - 참고 : https://docs.nvidia.com/cuda/wsl-user-guide/index.html\n - 주소에서 CUDA 드라이버를 다운받고 설치 https://developer.nvidia.com/cuda/wsl/download\n - 설치 후 컴퓨터 재시작\n ![image](https://user-images.githubusercontent.com/53217819/138554486-2c628817-f8de-4d97-95eb-22afdb8c2ab9.png)\n\n\n - powershell을 관리자 권한으로 열고\n  ```bash\n      wsl --install\n  ```\n  \n  - powershell을 관리자 권한으로 열고\n  ```bash\n      wsl --update\n  ```\n  \n\n - wsl 창을 열고 다음의 명령어를 입력하여 드라이버 설치\n ```bash\n wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-ubuntu2004.pin\n sudo mv cuda-ubuntu2004.pin /etc/apt/preferences.d/cuda-repository-pin-600\n wget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda-repo-ubuntu2004-11-4-local_11.4.0-470.42.01-1_amd64.deb\n sudo dpkg -i cuda-repo-ubuntu2004-11-4-local_11.4.0-470.42.01-1_amd64.deb\n sudo apt-key add /var/cuda-repo-ubuntu2004-11-4-local/7fa2af80.pub\n sudo apt-get update\n sudo apt-get install -y cuda-toolkit-11-4\n ```\n - nvidia-smi를 통해 설치 확인\n ```bash\n nvidia-smi\n ```\n![image](https://user-images.githubusercontent.com/53217819/138554608-6c2fd592-0cb8-482e-80e7-b7f9c41bc1fc.png)\n\n4. wsl을 이용하여 docker 설치 ( root권한으로 진행 추천.)\n```bash\ncurl https://get.docker.com | sh  \ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID)\ncurl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -\ncurl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list\nsudo apt-get update\nsudo apt-get install -y nvidia-docker2      \nsudo service docker stop\nsudo service docker start\n```\n5. wsl을 이용하여 Ros 설치\n ```bash\n sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list'\n sudo apt install curl \n curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -\n sudo apt update\nsudo apt install ros-noetic-desktop-full\necho \"source /opt/ros/noetic/setup.bash\" >> ~/.bashrc\nsource ~/.bashrc\nsudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential\nsudo apt install python3-rosdep\nsudo rosdep init\nrosdep update\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws\ncatkin_make\necho \"source ~/catkin_ws/devel/setup.sh\" >> ~/.bashrc\nsource ~/.bashrc\n\n\n ```\n \n+ Dynamixel SDK 설치\n```bash\n```\n+ Poco 설치\n```bash\n```\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 16,
    "title": "blender human",
    "content": "blender로 사람만들기 https://mb-lab-community.github.io/MB-Lab.github.io/ 이용\n\n## Blender 다운로드\nhttps://www.blender.org/\n![image](https://user-images.githubusercontent.com/53217819/153700209-8cbbc3a9-1aa1-4b17-8c67-611f6968e43e.png)\n## MB-Lab 다운로드\nhttps://github.com/animate1978/MB-Lab\n\ngithub에서 Download ZIP 클릭\n\n![image](https://user-images.githubusercontent.com/53217819/153700284-8db128ed-596e-4eb2-97de-7e1aff569bd5.png)\n\n## Start Blender \n![image](https://user-images.githubusercontent.com/53217819/153700242-8c9e9a8c-e184-4f69-8e59-8a7cb6c9843d.png)\n## Edit 메뉴에서 Preferences 선택\n![image](https://user-images.githubusercontent.com/53217819/153700255-91f93d8c-7b3c-4eda-9ca2-e13143ac6b6e.png)\n## Install 버튼 클릭\n![image](https://user-images.githubusercontent.com/53217819/153700308-831636b8-cd65-4f99-9091-e54ab68dd472.png)\n## 다운받은 MB-Lab-master.zip 선택\n![image](https://user-images.githubusercontent.com/53217819/153700323-5525f8ba-68c2-44a8-9254-b3b395e825ad.png)\n## 자동설치 후 다음화면 나옴\n![image](https://user-images.githubusercontent.com/53217819/153700332-d842dd85-a98d-4ec3-8923-cf59ba865466.png)\n## 우측 상단의 < 표시 클릭\n![image](https://user-images.githubusercontent.com/53217819/153700367-1086e36b-b202-42b3-bb97-9e8127eee875.png)\n## MB-Lab 탭 선택\n![image](https://user-images.githubusercontent.com/53217819/153700380-a1e04e50-e119-4f7b-b3e3-3c7d4c365d71.png)\n\n## Select 탭에서 Asian male 선택\n![image](https://user-images.githubusercontent.com/53217819/153700392-387c87e8-200a-4c3a-b333-f8a14a2617a9.png)\n\n## Create character 선택\n![image](https://user-images.githubusercontent.com/53217819/153700421-a2e0c25e-4af4-4fe1-a659-cc406abde3c5.png)\n## 생성된 캐릭터를 확인\n![image](https://user-images.githubusercontent.com/53217819/153700451-80be4137-e249-4093-81c9-54c6cd27cb3c.png)\n\n## Pose모드 진입\n![image](https://user-images.githubusercontent.com/53217819/153700460-a42d5daf-38a7-4172-b6c6-8e4087491c10.png)\n\n## Viewport 를 X-ray타입으로 변경하고 몸의 중심의 위치를 변경\n![image](https://user-images.githubusercontent.com/53217819/153700511-9870bfa8-5330-475e-afd0-912bccbcc811.png)\n![image](https://user-images.githubusercontent.com/53217819/153700532-43ab55d1-37d6-403a-9ff6-3bfeeef38c0a.png)\n\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 17,
    "title": "Indy7 SDK Linux 설정방법",
    "content": "# 1.SDK install\n```bash\nwget https://s3.ap-northeast-2.amazonaws.com/download.neuromeka.com/SDK-Installer/NRMKFoundation/Linux/NRMKIndySDK_v3.0.9_b20190729.tar.gz\nwget https://s3.ap-northeast-2.amazonaws.com/download.neuromeka.com/SDK-Installer/LeanFramework/Linux/NRMKIndySDK-Lean-v2.3.0.1.tar.gz\ntar xvf NRMKIndySDK*.tar.gz\n\ncd NRMKIndySDK_v3.0.9_b20190729\n./install.sh\n./postinst.sh\ncd ../\n\ncd NRMKIndySDK-Lean-v2.3.0.1\n./install.sh\n source /opt/neuromeka/NRMKFoundation/script/nrmk_indy_env.sh\n source /opt/neuromeka/NRMKFoundation/script/nrmk_indy_lean_env.sh\n```\n# 2. Example build\n```bash\ncd /opt/neuromeka/NRMKFoundation/example/LeanComponents/SampleJointControlComponent\ncd build\ncmake ..\nmake -j16\n\n```\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 18,
    "title": "Modern Robotics MATLAB Example",
    "content": "이 post는 MATLAB을 이용해 Modern robotics 책의 8장까지의 내용을 구현하는 과정을 담고 있습니다.\n예제파일은   [https://github.com/tjdalsckd/ModernRobotics_Matlab_Example](https://github.com/tjdalsckd/ModernRobotics_Matlab_Example) 에 포함되어 있습니다.\n\n## load URDF\n다운받은 폴더에 불러오려는 urdf 파일을 넣고 다음과 같음 함수로 Slist,Mlist,Glist,M,w,p,robot을 얻을 수 있습니다.\n\n\n- w : 각 조인트의 회전 축 방향값입니다. 조인트 개수가 n개일 때, n x 3 행렬로 구성되어 있습니다.\n- p : 각 조인트의 회전 축 위치값입니다. 조인트 개수가 n개일 때, n x 3 행렬로 구성되어 있습니다.\n\n- Slist : Screw list, Forward Kinematics를 해석하기 위한 값입니다. w와 p를 이용하여 선속도 v =(- w x p)을 구하고, $S_i=[w(1), w(2), w(3), v(1), v(2), v(3)]^{T}$ 와 같이 계산되는 값입니다. base로부터 각 조인트 위치의 Screw 값을 담고 있습니다.\n\n- Mlist : CoM에 대한 정보를 담고 있는 행렬값입니다. Dynamics해석을 위해 필요한 행렬이며 조인트의 개수가 n개 일때, base frame을 {0}이라 하고 end effector frame을 {n+1}이라 정의하면 CoM까지의 Homogeneous Transformation은 다음과 같이 표현됩니다.(i는 0 ~ n+1)\n\n    - $M_{0,1}$ : base부터 1번 링크의 CoM까지의 Homogeneous Transformation \n\n    - $M_{1,2}$ : 1번 링크의 CoM부터  2번 링크의 CoM까지의 Homogeneous Transformation \n\n    - $M_{i-1,i}$ : i-1번 링크의 CoM부터  i번 링크의 CoM까지의 Homogeneous Transformation \n\n- Glist : Inertia Matrix와 mass 값을 이용한 6x6 행렬값입니다. base link는 제외하고 생성합니다.\n\n- robot : matlab importrobot함수의 리턴값입니다.\n\n\n```bash\n  [Slist,Mlist,Glist,M,w,p,robot] = load_urdf(\"indy7.urdf\",6)\n```\n\n## Forward Kinematics\n각 조인트 위치까지의 Forward Kinematics를 계산합니다.\n- FKlist : FK의 결과인 Homogeneous Transformation들의 값입니다. FKlist{end}는 end-effector의 Homogeneous Transformation을 의미합니다.\n\n```bash\n   FKlist = getFKlist(w,p,thetalist,M);\n```\n\n## Forward Dynamics\n현재의 토크입력, 끝단힘, 위치, 속도, 가속도 등을 이용하여 다음 상태의 가속도를 계산합니다.\n```bash\n    taulist = [0,0,0,0,0,0]';\n    Ftip = [0,0,0,0,0,0]';\n    ddthetalist = ForwardDynamics(thetalist, dthetalist, taulist, ...\n                                           g, Ftip, Mlist, Glist, Slist);\n```\n## Inverse Dynamics \n- Mass Matrix\n```bash\n  mMat = MassMatrix(thetalist, Mlist, Glist, Slist)\n```\n- coriolis Matrix\n```bash\n  cMat = VelQuadraticForces(thetalist, dthetalist, Mlist, Glist, Slist)\n```\n\n- Gravity Matrix\n```bash\n  g = [0; 0; -9.8];\n  gMat = GravityForces(thetalist, g, Mlist, Glist, Slist)\n```\n\n## 시뮬레이션 영상\n![ezgif com-gif-maker (6)](https://user-images.githubusercontent.com/53217819/158019802-aa66b9f2-74de-4e49-9967-e2c0d886cf86.gif)\n\n\nhttps://catalog.ngc.nvidia.com/orgs/nvidia/containers/isaac-sim\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 19,
    "title": "Ubuntu20.04.2 Xenomai3.1 커널세팅",
    "content": "# 1. Ubuntu 20.04.2 설치\n     https://old-releases.ubuntu.com/releases/20.04.2/ubuntu-20.04.2-desktop-amd64.iso\n# 2. Rufus 설치\n     https://github.com/pbatard/rufus/releases/download/v3.20/rufus-3.20.exe\n# 3. 부팅USB제작 (8GB이상의 USB)\n![image](https://user-images.githubusercontent.com/53217819/201559045-72bb0aba-7cb1-4b70-95e6-8e0ed5bc6171.png)\n\n# 4. 재시작 후 Ubuntu 20.04.2 설치진행\n# 5. 기본 라이브러리 설치\n``` bash\n    sudo apt install build-essential kernel-package libncurses5-dev libelf-dev openssl libssl-dev libtool libltdl-dev git distcc xenomai-system-tools rt-tests libc-dev libc6-dev pkg-config ncurses-dev stress autoconf libncurses-dev flex bison libssl-dev dkms libelf-dev libudev-dev libpci-dev libiberty-dev dwarves\n```\n설치 시 중간에 아래와 같은 창이 뜰텐데 install the package maintainer's version  선택\n![image](https://user-images.githubusercontent.com/53217819/201562515-7dcc376e-19c0-4a73-8252-8277f50108cf.png)\n\n\n```bash\n\tmkdir ~/xeno_ws\n\tcd ~/xeno_ws\n\texport xeno_home=$PWD\n```\n![image](https://user-images.githubusercontent.com/53217819/201927710-28f44a75-2ab4-41e9-a2d8-e23c4969524d.png)\n\n# 6. Xenomai 3.1.1 다운로드\n아래와 같이 Xenomai 3.1.1을 다운로드\n```bash\n\tcd $xeno_home\n\tgit config --global http.sslverify false\n\tgit clone https://source.denx.de/Xenomai/xenomai.git\n\tcd xenomai \n\tgit checkout v3.1.1 \n\tcd ../\n```\n\n# 7. Linux 5.4.124 커널 다운로드\n아래와 같이 Linux 5.4.124 커널을 다운로드\n```bash\n\tcd $xeno_home\n\twget https://www.kernel.org/pub/linux/kernel/v5.x/linux-5.4.124.tar.gz\n\ttar -xf linux-5.4.124.tar.gz\n\tcd linux-5.4.124\n\texport linux_path=$PWD\n```\n\n# 8. Xenomai ipipe 다운로드\n```bash\n\tcd $linux_path\n\twget https://xenomai.org/downloads/ipipe/v5.x/x86/ipipe-core-5.4.124-x86-5.patch\n```\n# 9. Xenomai ipipe patch진행\n```bash\n\tcd $linux_path\n\t../xenomai/scripts/prepare-kernel.sh --arch=x86_64 --ipipe=ipipe-core-5.4.124-x86-5.patch\n```\n\n# 10. Kernel 빌드 전 상세설정 진행\n```bash\n\tcd $linux_path\n\tsudo make menuconfig\n```\n![image](https://user-images.githubusercontent.com/53217819/201929364-cc82fd5c-748c-46b1-8411-b58367b917e9.png)\n\n#### General setup\n\n\t--> Local version - append to kernel release: -xenomai-3.1.1\n\n\t--> Timers subsystem\n\n\t\t--> High Resolution Timer Support (Enable)\n\n\t-->  Preemption Model\n\n\t\t--> Preemption Kernel (Low-Latency Desktop)\n\n#### Pocessor type and features\n\t--> Numa Memory Allocation and Scheduler Support (Disable)\n\n\t--> Linux guest support (Disable)\n\n\t--> Processor family\n\n\t\t--> Core 2/newer Xeon\n\n\t\t--> if \"`cat /proc/cpuinfo | grep family`\" returns 6, set as Generic otherwise\n\n\t// Xenomai will issue a warning about CONFIG_MIGRATION, disable those in this order\n\n\t--> Multi-core scheduler support (Enable)\n\n\t--> CPU core priorities scheduler support (Disable)\n\n\t--> Timer frequency (1000 Hz)\n\n#### Power management and ACPI options\n\t--> ACPI (Advanced Configuration and Power Interface) Support (disable)\n\t--> CPU Frequency scaling (disable)\n\t--> CPU Idle --> CPU idle PM support (disable)\n \n#### Xenomai/cobalt\n\t--> Sizes and static limits\n\t\t--> Number of registry slots (512 --> 4096)\n\t\t--> Size of system heap (Kb) (512 --> 4096)\n\t\t--> Size of private heap (Kb) (64 --> 256)\n\t\t--> Size of shared heap (Kb) (64 --> 256)\n\t\t--> Maximum number of POSIX timers per process (128 --> 512)\n\t--> Drivers\n\t\t--> Real-time IPC drivers\n\t\t\t--> RTIPC protocol family(Enable)\n\t\t--> RTnet\n\t\t\t--> RTnet, TCP/IP socket interface (enable)\n\t\t\t\t--> Protocol stack --> TCP support (enable)\n             \n#### Memory Management options\n\t--> Transparent Hugepage Support (Disable)\n\t--> Contiguous Memory Allocator (Disable)\n\t--> Allow for memory compaction (Disable)\n\t\t--> Page Migration (Disable)\n \n#### Device Drivers\n\t--> Staging drivers\n\t\t--> Unisys SPAR driver support (Disable)\n\t--> Network device support(enable)\n\t\t--> Ethernet driver support (enable)\n\t\t--> # enable ethernet driver w.r.t. each h/w system\n\n#### Kernel hacking\n\t--> KGDB: kernel debugger (Disable)\n\n#### EFI error 발생 시 (https://stackoverflow.com/questions/40344484/cant-load-self-compiled-linux-kernel)\n\tPower management and ACPI options --->\n\t\t[*] ACPI (Advanced Configuration and Power Interface) Support --->\n\tProcessor type and features  --->\n\t\t[*] EFI runtime service support \n\t\t[*]   EFI stub support\n\tFirmware Drivers  --->\n\t\tEFI (Extensible Firmware Interface) Support  --->\n\t\t<*> EFI Variable Support via sysfs\n설정 저장\n![image](https://user-images.githubusercontent.com/53217819/201931772-cec4f65e-3a88-4d81-9c40-48636ae1637a.png)\n\n# 11. 설정 완료 후 빌드 진행(예상소요시간 1시간)\ncpu 코어 수에 맞춰서 --J n 설정\n```bash\n\tcd $linux_path\n\tsudo CONCURRENCY_LEVEL=$(nproc) make-kpkg --J 4 --rootcmd fakeroot --initrd kernel_image kernel_headers\n```\n# 12. 빌드 완료 후 생성된 deb파일을 dpkg를 통해 설치\n```bash\n\tcd $xeno_home\n\tsudo dpkg -i linux-headers-5.4.124-xenomai-3.1.1_5.4.124-xenomai-3.1.1-10.00.Custom_amd64.deb linux-image-5.4.124-xenomai-3.1.1_5.4.124-xenomai-3.1.1-10.00.Custom_amd64.deb\n\n```\n\n# 13. Allow non-root user\n```bash\n\tsudo addgroup xenomai --gid 1234\n\tsudo addgroup root xenomai\n\tsudo usermod -a -G xenomai $USER\n```\n# 14. grub File 설정\n```bash\n\tgedit /etc/default/grub\n```\n아래와 같이 수정\n\t\n```\n\tGRUB_DEFAULT=\"0\"\n\tGRUB_HIDDEN_TIMEOUT=\"5\"\n\tGRUB_HIDDEN_TIMEOUT_QUIET=\"true\"\n\tGRUB_DISTRIBUTOR=\"`lsb_release -i -s 2> /dev/null || echo Debian`\"\n\tGRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash xenomai.allowed_group=1234\"\n\tGRUB_CMDLINE_LINUX=\"\"\n```\n# 15. grub설정 후 재시작\n```bash\n\tsudo update-grub\n\tsudo reboot\n```\n# 16. 재시작 후 grub창 xenomai선택\n\n\tAdvanced Options for Ubuntu \n\t\t--> Ubuntu, with Linux 5.4.124-xenomai-3.1.1\n# 17. 터미널 창에서 xenomai 커널 확인\n```bash\n\tuname -a\n```\n![image](https://user-images.githubusercontent.com/53217819/201934786-7c399fdc-cb06-4f97-9aab-db8df690c9aa.png)\n# 18. xenomai build\n```bash\n\tcd ~/xeno_ws/xenomai\n\tautomake --add-missing\n\tautoreconf -i\n\t./configure --with-pic --with-core=cobalt --enable-smp --disable-tls --enable-dlopen-libs --disable-clock-monotonic-raw\n\tsudo make -j4\n\tsudo make install\n\techo '\n\t### Xenomai\n\texport XENOMAI_ROOT_DIR=/usr/xenomai\n\texport XENOMAI_PATH=/usr/xenomai\n\texport PATH=$PATH:$XENOMAI_PATH/bin:$XENOMAI_PATH/sbin\n\texport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$XENOMAI_PATH/lib/pkgconfig\n\texport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XENOMAI_PATH/lib\n\texport OROCOS_TARGET=xenomai\n\t' >> ~/.bashrc\n\tsource ~/.bashrc\n\tsudo chmod -R 777 /dev/rtdm/memdev-private\n\tsudo chmod -R 777 /dev/rtdm/memdev-shared\n\t# If you have a problem that sudo does not recognize the SHARED LIBRARY PATH, type the following command.\n\tcd /etc/ld.so.conf.d/\n\tsudo gedit xenomai.conf\n\t'\n\t### Multiarch support\n\t/usr/xenomai/lib\n\t\n\t'\n\tsudo ldconfig -v\n\n\t\n```\n# 19. Xenomai Test\n```bash\n \tcd /usr/xenomai/bin\n\tsudo ./latency\n```\n![image](https://user-images.githubusercontent.com/53217819/201935888-23a03417-c025-4e2c-8265-b30a72549d9b.png)\n\n\n\n\n######  Fix negative latency issues\nYou need to be in root sudo -s, then you can set values to the latency calibration variable in nanoseconds:\n```bash\necho 0 > /proc/xenomai/latency\n```\n# Now run the latency test\n\n# If the minimum latency value is positive,\n# then get the lowest value from the latency test (ex: 0.088 us)\n# and write it to the calibration file ( here you have to write 88 ns) :\n```bash\n echo ${my_super_value_in_ns} > /proc/xenomai/latency\n```\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 20,
    "title": " 이미지를 Latex 문법으로 변환",
    "content": "https://github.com/tjdalsckd/image2latex_mathpix\n\nMathpix.com의 API를 사용하여 Snapshot 이미지를 Latex 문법으로 변환시키는 Python 프로그램입니다.\n\n![91204626c10260f7fef75498fef5c103](https://user-images.githubusercontent.com/53217819/91944373-eee29680-ed38-11ea-80e5-9b64514dfe82.png)\n\n좌측의 이미지와 같이 손글씨 이미지 또한 캡처 후 Mathpix API를 사용하여 우측의 Latex 문법으로 변환이 가능합니다.\n\n프로그램은 API ID,KEY를 입력하는 프로그램과 메인 프로그램 두 가지로 구성되어있습니다.\n\n프로그램을 사용하기 위해서는 Mathpix.com에서 API ID,KEY를 할당받아야합니다.\n\n먼저 Mathpix.com에 가입합니다.\n\n![캡처fffff](https://user-images.githubusercontent.com/53217819/91945024-bee7c300-ed39-11ea-81fd-523d67df75b2.PNG)\n\n가입 후 로그인을 합니다.\n\n![캡처fdfdfdf](https://user-images.githubusercontent.com/53217819/91945842-0706e580-ed3a-11ea-9bac-133b66e93d20.PNG)\n\n위와 같은 로그인 화면에서 OCR API 탭을 선택합니다. \n\n선택 후 결제 카드를 입력하면 다음과 같이 API ID와 KEY를 할당 받을 수 있습니다.\n\n![캡처fdewweierjrweewr](https://user-images.githubusercontent.com/53217819/91946858-5a793380-ed3a-11ea-85a4-ae9ccf8d71f4.PNG)\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 21,
    "title": "Ubuntu20.04.2 Xenomai3.1 Alienware aurora a15",
    "content": "# ubuntu 20.04.6 \n# Xenomai 3.1.1\n# NVIDIA DRIVER\n\n``` bash\nwget https://kr.download.nvidia.com/XFree86/Linux-x86_64/535.113.01/NVIDIA-Linux-x86_64-535.113.01.run\nchmod 777 NVIDIA-Linux-x86_64-535.113.01.run\n```\n```bash\nsudo gedit /etc/modprobe.d/blacklist.conf\n```\n```bash\nblacklist nouveau\nblacklist lbm-nouveau\noptions nouveau modeset=0\nalias nouveau off\nalias lbm-nouveau off\n```\n\n```bash\necho options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf\nsudo update-initramfs -u\nsudo init 3\n```\n# CUDA 11.8\n```bash\nwget https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda_11.8.0_520.61.05_linux.run\n```\n```bash\nsudo gedit ~/.bashrc\n```\n```bash\nexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH\nexport PATH=/usr/local/cuda/bin:$PATH\n```\n\n# network_driver\n```bash\nhttps://www.realtek.com/en/directly-download?downloadid=e3140146c05ec811caa824c14016ba09\nsudo apt install r8168-dkms\nsudo chmod 777 autorun.sh\nsudo ./autorun.sh\nsudo reboot\n```\n\n",
    "tag": "etc",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 22,
    "title": "chapter10",
    "content": "# Lie Groups 1: Introduction and Examples\n*Lie groups*은 노르웨이 수학자 Sopus Lie가 이름지은 *group*의 special case이다. 나아가 일반적인 로봇 책에서 다루는 Lie groups*은 역행렬을 갖는 정방행렬들을 원소로 하는 *matrix Lie groups*를 다룬다. \n\nmatrix Lie groups은 vector spaces외의 수학적 구조에서 \"the most like $\\mathbb{R}^{n}$\"라고 한다. 실제로 $\\mathbb{R}^{n}$은 $+$ 연산과 함께 Lie Groups의 예시로 볼 수 있다. 좀 더 일반화 하여 보면 어떤 Lie Group상의 점 $G$와 $\\mathbb{R}^n$상의 어떤 점은 locally indistinguishable하며, globally하게는 $G$는 orientable이다. 점 근처만 본다고 하면 $\\mathbb{R}^{n}$과 유사하지만 globally하게 본다면 $\\mathbb{R}^{n}$과 달리 방향을 갖는다. \n\n일반적으로 matrix Lie Groups에서는 연산자를 표기하지 않는다. 왜냐면 연산자가 행렬곱임이 명백하기 때문이다. 그러나 일반적인 Lie Groups를 다룰 때에는 항상 연산에 대한 논의가 필요하다. 따라서 연산자 $\\circ$라고 정의하여 사용한다. $\\circ$ 연산은 $g_1, g_2 \\in G$일 때 $g_1 \\circ g_2 \\in G$를 만족하는 연산이다. 비슷한 연산은 두 벡터간의 덧셈($+$)연산이 있다. 기억해야할 중요한 점 두가지 \n\n 1. Lie Groups는 일반적으로 \"not comutative\"이다. 즉, $g_1 \\circ g_2 \\neq g_2 \\circ g_1$을 만족해야할 필요는 없다. \n 2. group내의 원소에 scalar를 곱하여 같은 group의 원소를 생성하는 것 또한 불가능하다.\n\n## 10.1 Introduction to Group Theroy\n\n### 10.1.1 Binary Operation\nGroup은 집합(set)과 연산(operation)으로 쌍을 이룬다. 어떤 set $G$가 주어졌을때 \"*(closed) binary operation*\"이란 $G$의 어떤 두개의 원소가 연산에 의해서 다시 $G$로 되돌아오는 연산을 의미한다. \n\n\n```note\n$b:G \\times G \\rightarrow G$  with  $b(g_1,g_2) \\doteq g_1 \\circ g_2$\n```\n\n어떤 책에서는 $b(\\cdot, \\cdot)$ 이런 식으로 사용하기도 하고, 다른 어떤 책에서는 $\\circ$를 이용해서 나타내기도 한다. \n\n\n그럼 binary operation의 예시를 들어보자. 정방행렬 set $G = \\mathbb{R}^{N \\times N}$라하고 $G$의 원소 $A,B \\in G$일 때,\n\n```note\n  $\\circ$ = matrix multiplication\n\n  $A \\circ B = AB \\in G$\n```\n따라서 matrix multiplication은 binary operation이다. 다른 예시로 sum(+)연산의 경우도 해당된다. 3차원 벡터들로 예시를 들면 cross product($\\times$)의 경우도 binary operation에 해당된다. 추가로 premutation연산도 binary operation에 해당한다.\n\n\n그러나 모든 연산자가 binary operation은 아니다. 예시로 dot product($\\cdot$)나 wedge product($\\wedge$)(outer product는 벡터와 벡터를 연산하여 해당 세트의 벡터로 연산한다, 그러나 wedge product는 선, 면, 공간 등을 연산하여 다른 차원의 세트로 변환한다.)는 set의 원소가 다른 set으로 이동하므로 binary operation이 아니다. 유사하게 행렬 곱 중 정방행렬간의 곱이 아닌 서로 다른 크기의 행렬일 경우 matrix multiplication은 binary operation이 아니다.\n\n\n### 10.1.2 Groups, Groupoids, and Semi-groups\n\n```note\nThe pair $(G,\\circ)$ consisting of the set $G$ and binary operation $\\circ$ form a mathematical structure that is called a *groupoid* or a *magma*\n```\n\ngroupoid라는 단어가 다른 의미를 다룰 수 도 있지만 여기서는 Group을 정의하기 위한 보다 큰 Category로 본다.\n\n```note\n  A *group* is a special kind of groupoid such that for any elements $g, g_1, g_2, g_3 \\in G$, the\n  following properties hold:\n\n\n  1. $g_1 \\circ (g_2 \\circ g_3) =  (g_1 \\circ g_2) \\circ g_3 $\n\n\n  2. There exists an element $e \\in G$ such that $e \\circ g = g$.\n\n\n  3. For every element $g \\in G$, there is an element $g^{-1} \\in G$ such that $g^{-1} \\circ g = e$\n\n```\n\n첫번째 특성을 결합법칙(associativity)이라 하고, 두번째 특성에서의 $e$를 $G$의 항등원(*identity* of $G$)라 한다. 그리고 $g^{-1}$를 $g \\in G$의 역원(*inverse*)라고 한다. group은 위의 세 가지를 만족하면 성립하지만 특수하게 교환법칙이 성립하는 경우가 있다. 이러한 group의 경우 *commutative* group 또는 *Abelian* group이라 한다.\n\n\n### A Concrete Example: Symmetry Operation on the Equilateral Triangle\n\n어떤 형태를 유지한 채로의 연산은 group으로 설명할 수 있다. 예를 들어 어떤 원을 다른 위치의 원으로 이동시키거나, 공간 상의 어떤 직선을 다른 방향과 다른 위치로 변환하는 것처럼 형태를 유지한 채의 연산을 설명할 때에 group의 예로 설명된다. 다음의 예제는 정삼각형의 테이블의 꼭지점에 시계방향으로 1,2,3을 표기했다. 테이블 외부에도 1,2,3으로 표기되어 있으며 이것은 변하지 않는 상태이다. 테이블을 회전할 수 있으며 다음과 같이 여섯개의 상태로 정의하자.\n![image](https://github.com/MinchangSung0223/MinchangSung0223.github.io/assets/53217819/f9e30619-0dae-4a2c-a985-59a29b87b7a8)\n\n1. $g_0=e$, 아무런 움직임이 없는 경우이다. \n2. $g_1$, 시계 반대방향으로 $2\\pi/3 [rad]$ 만큼 회전\n3. $g_2$, 시계 반대방향으로 $4\\pi/3 [rad]$ 만큼 회전\n4. $g_3$, 테이블의 1과 테이블 밖의 1을 맞추고 $\\pi [rad]$ 만큼 회전\n5. $g_4$, 테이블의 2와 테이블 밖의 2를 맞추고 $\\pi [rad]$ 만큼 회전\n6. $g_5$, 테이블의 3과 테이블 밖의 3을 맞추고 $\\pi [rad]$ 만큼 회전\n\n이 연산들의 set을 다음과 같이 정의하자\n\n$$\n  G_T \\doteq \\{ e,g_1,g_2,g_3,g_4,g_5\\}.\n$$\n\n이제 set $G_T$의 원소들 간의 연산을 $\\circ$로 정의하고 각 원소별 연산결과를 표로 나타내면 다음과 같다.\n\n| $\\circ$ | $e$ | $g_1$ | $g_2$ | $g_3$ | $g_4$ | $g_5$ |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| $e$ | $e$ | $g_1$ | $g_2$ | $g_3$ | $g_4$ | $g_5$ |\n| $g_1$ | $g_1$ | $g_2$ | $e$ | $g_4$ | $g_5$ | $g_3$ |\n| $g_2$ | $g_2$ | $e$ | $g_1$ | $g_5$ | $g_3$ | $g_4$ |\n| $g_3$ | $g_3$ | $g_5$ | $g_4$ | $e$ | $g_2$ | $g_1$ |\n| $g_4$ | $g_4$ | $g_3$ | $g_5$ | $g_1$ | $e$ | $g_2$ |\n| $g_5$ | $g_5$ | $g_4$ | $g_3$ | $g_2$ | $g_1$ | $e$ |\n\n\n그럼 이 표를 이용해서 group $(G_T, \\circ)$가 group의 정의를 만족하는가를 확인해보자.(단,$\\circ$는 binary operation)\n\n1. $(G_T, \\circ)$는 $g_i,g_j,g_k \\in G_T$에 대해서 $(g_i \\circ g_j) \\circ g_k=g_i \\circ (g_j \\circ g_k)$를 만족.\n2. 모든 원소에 대한 항등원 $e$가 존재하며 unique\n3. 모든 원소에 대한 역원 $g^{-1}$가 존재하며 unique. (ex. $g_2 \\circ g_1 = e$)\n\n따라서 $(G_T,\\circ)$는 group의 정의를 만족하며 group이라 할 수 있다.\n\n#### Abstract Group Theroy\nset $\\mathbb{R}^3$과 cross product연산은 왜 group이 아닐까? \n\n1. cross product는 not associative\n$$\n  (\\mathbf{a} \\times  \\mathbf{b}) \\times \\mathbf{c} \\neq \\mathbf{a} \\times  (\\mathbf{b} \\times \\mathbf{c})\n$$\n\n2. 항등원이 없음.\n3. 역원 또한 없음.\n\n\n그럼 $\\mathbb{R}^{N\\times N}$과 matrix multiplication은 group일까? 이때는 \"almost\" a group이라 하는데 왜그럴까? 일반적으로 matrix는 singular인 경우 역원이 존재하지 않는다. 이경우에 대해서는 3번 성질이 성립하지 않고 이때는 *semi-group*이라 일컷는다.\n\n\n역행렬이 존재하는 $N \\times N$ 실수 정방행렬 set를 다음과 같이 정의한다.\n\n$$\n  GL(N,\\mathbb{R}) \\doteq \\{ A \\in \\mathbb{R}^{N\\times n} | det A \\neq 0\\}\n$$\n\n이 set은 matrix multiplication 연산과 함께 the *general linear group* \"over the real numbers\"라 한다. 보다 일반적으로는 $\\mathbb{R}$은 어떤 field $\\mathbb{F}$나, 복소수 $\\mathbb{C}$ 등으로 대체될 수 있다.\n\n\n이 group의 항등원은 $\\mathbb{I}_N$이라 나타내며 대각 원소가 1인 $N \\times N$ identity matirx이다.\n\n\ndeterminant가 항상 양수인 positive matrix에 대한 set은 다음과 같이 정의한다.\n\n$$\n  GL^{+}(N,\\mathbb{R}) \\doteq \\{ A \\in \\mathbb{R}^{N\\times n} | det A > 0\\}\n$$\n\n위의 set도 matrix multiplication 연산과 같이 group으로 정의된다. 일반적으로 행렬에 대한 set들은 matrix multiplication 연산자가 당연하기 때문에 set의 이름을 그대로 group의 이름으로 종종 사용한다.\n### 10.1.3 Subgroups\n```note\nA *subgroup* is a subset of a group $( H \\subseteq G)$ which is itself a group that is closed under the group operation of $G$. This means that $h^{-1} \\in H$ whenever $h \\in H$. The notation for this is $H \\leq G$. If $H \\leq G$ and $H \\neq G$, then $H$ is called a proper subgroup of $G$, which is denoted as $H<G$. This notation parallels that of a proper subset. Each group has at least two improper subgroups: $\\{e\\}$ and itself.\n```\n\n*subgroup*이란 group의 subset$(H \\subseteq G)$인데 $G$의 group operation에 대해서 closed인 subset을 의미한다.\n이 의미는 $h \\in H$에 대해서 $h^{-1} \\in H$가 항상 존재함을 의미하며 $H\\leq G$로 표현한다. 이때 $H \\neq G$인 경우에 대해서는 *proper subgroup* of $G$라 하고 $H<G$로 나타낸다. \n각 group은 $\\{e\\}$과 group자기자신으로 적어도 두개의 improper subgroups를 갖는다.\n\n\n예시로 실수는 복소수의 special case이다. 따라서 $GL(N,\\mathbb{R}) < GL(N,\\mathbb{C})$이며, $\\mathrm{det}(AB) = \\mathrm{det}(A)\\mathrm{det}(B)$이므로\n\n$$\n  SL(N,\\mathbb{F}) \\doteq \\{ A \\in  \\mathbb{F}^{N \\times N} | \\mathrm{det}(A) = +1 \\} \\subset GL(N,\\mathbb{F})\n$$\n\n위와 같이 *special linear group*을 정의할 수 있다. 그리고 $SL(N,\\mathbb{F}) < GL(N,\\mathbb{F})$ 이다.\n\n다른 예제로는 $GL(N,\\mathbf{C})$의 subset인 *unitary group*이 있다. \n\n$$\n  U(N) \\doteq \\{ A \\in  \\mathbb{C}^{N \\times N} | AA^{\\ast} = \\mathbf{I} \\} < GL(N,\\mathbb{C})\n$$\n\n\n*special unitary group*\n\n$$\n  SU(N) \\doteq U(N) \\cap SL(N,\\mathbf{C}) < GL(N,\\mathbb{C})\n$$\n\n\n*orthogonal group*\n\n\n$$\n  O(N,\\mathbb{R})\\doteq \\{ A \\in GL(N,\\mathbb{R}) | AA^T = \\mathbb{I}\\} = U(N) \\cap GL(N,\\mathbb{R})\n$$\n\n\n*special orthogonal group*\n\n\n$$\n  SO(N)\\doteq \\{ A \\in GL(N,\\mathbb{R}) | AA^T = \\mathbb{I},\\mathrm{det} A = 1 \\} = U(N) \\cap SL(N,\\mathbb{R})\n$$\n\n\n*conjugate subgroup* \n\n\ngroup theory에서 종종 다뤄지는 부분으로 여기서 subgroup은 group의 operation에 의한 conjugate연산에 의해서 생성된다.\n\n$$\n\\begin{aligned}\ngHg^{-1} \\doteq& \\{ g \\circ h \\circ g^{-1} | h \\in H\\} \n\\\\ \n&\\text{ for a single(fixed) } g \\in G \\text{ with }  g \\notin H<G\n\\end{aligned}\n$$\n\n\n예를들면 만약 $G = SO(3)$ 이고 $H \\cong SO(2) $라 할때($\\cong$의 의미는 근본적으로는 같으나 같진 않은 경우) 다음과 같이 행렬을 구성하자.\n\n$$\nR_3(\\theta)=\\left(\\begin{array}{ccc}\n\\cos \\theta & -\\sin \\theta & 0 \\\\\n\\sin \\theta & \\cos \\theta & 0 \\\\\n0 & 0 & 1\n\\end{array}\\right)\n$$\n\n만약에 $g_n = [\\mathbf{a},\\mathbf{b},\\mathbf{n}] \\in SO(3)$ 이면 subgroup $K_n \\doteq g_n H g^{-1}_n < SO(3)$으로 정의하며 위의 행렬처럼 정의한 경우 conjugate 연산한 경우 $\\mathbf{n}$은 고정된다. \n\n\n일반적으로 만약 $H_1,H_2 \\leq G$이며 모든 g에 대해서 $gH_1g^{-1} = H_2$인 경우 \"$H_1$와 $H_2$는 서로 conjugate하다\"라고 한다. \n\n어떤 subgroup $N\\leq G$이며 모든 $g \\in G$에 대해 $gNg^{-1} = N$라면  \"*normal* subgroup of $G$\"라고 한다.(자기 자신에 대해서 conjugate한 경우). 이 경우 $N \\unlhd G$로 표기한다. 이때 $N=G$가 가능한 경우이며 $N \\neq G$인 경우는 $N\\lhd G$로 표기한다.( normal and proper subgroup)\n\n그럼 table예제로 돌아가보자. 예제에서의 proper subgroups는 table을 보고 구할 수 있다.\n\n\n| $\\circ$ | $e$ | $g_1$ | $g_2$ | $g_3$ | $g_4$ | $g_5$ |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| $e$ | $e$ | $g_1$ | $g_2$ | $g_3$ | $g_4$ | $g_5$ |\n| $g_1$ | $g_1$ | $g_2$ | $e$ | $g_4$ | $g_5$ | $g_3$ |\n| $g_2$ | $g_2$ | $e$ | $g_1$ | $g_5$ | $g_3$ | $g_4$ |\n| $g_3$ | $g_3$ | $g_5$ | $g_4$ | $e$ | $g_2$ | $g_1$ |\n| $g_4$ | $g_4$ | $g_3$ | $g_5$ | $g_1$ | $e$ | $g_2$ |\n| $g_5$ | $g_5$ | $g_4$ | $g_3$ | $g_2$ | $g_1$ | $e$ |\n\nproper subgroups : $\\{e\\}, H_1 = \\{e,g_1,g_2  \\}, H_2 = \\{e,g_3 \\},H_3=\\{e,g_4\\} \\text{ and } H_4=\\{e,g_4 \\}$\n\nsubgroup H_2,H_3,H_4는 서로 conjugate하다. \n\n$$\ng_1 H_2 g_1^{-1} = H_4; ~~ \ng_1 H_3 g_1^{-1} = H_2; ~~\ng_1 H_4 g_1^{-1} = H_3\n$$\n\n모든 $g \\in G$에 대해서 H_1은 자신에 대해 conjugate이므로 normal subgroup이다.\n\n$$\ng H_1 g^{-1} = H_1\n$$\n\n두개의 subgroup $H \\neq G$와 $K \\neq G$일때 product는\n\n$$\nHK \\doteq \\{h \\circ k | h \\in H, k \\in K \\}\n$$\n\n로 정의하고 subset $HK \\subseteq G$ 이 된다.(subgroup의 특성을 갖추지 않을 수 있음). \n\ntable group $(G_T,\\circ)$로 예를 들면, \n\n$$\n\\begin{aligned}\nH_1H_i = H_iH_1 = G \\text{ for } i=2,3,4\\\\\nH_2H_3 = \\{e,g_2,g_3,g_4\\} \\subset G\\\\\nH_3H_2 = \\{e,g_1,g_3,g_4\\} \\subset G\n\\end{aligned}\n$$\n\n여기서 만약 $N \\unlhd G$ 이며 $H \\neq G$이면 $NH=HN$이다. 그러나 subgroups중에 하나가 normal이 아니라면 성립하지 않음.\n\n### 10.1.4 Group Actions and Transformation Groups\n*transformation group* \n```note\n*transformation group* $(G,\\circ)$  is a group that acts on a set S in such a way that $g \\cdot x \\in S$ is defined for all $x \\in S$ and $g \\in G$ and has the properties\n\n\n$$\n e \\cdot x  = x\n$$\n$$\n (g_1 \\circ g_2) \\cdot x = g_1 \\cdot (g_2 \\cdot x) \\in S\n$$\n\nfor all $x \\in S$ and $e,g_1,g_2 \\in G$. The operation $\\cdot$ defines the *action* of $G$ on $S$\n```\n\n여기서 $\\cdot$으로 표기되는 operation을 *action*으로 정의한다. 어떤 set S상에서의 원소를 S의 다른 원소로 이동시키는 것을 의미한다. 이 때 $g \\cdot x = x$ 인 경우, 즉 x에 대한 g의 action이 x가 되는 경우 $g$가 $G$의 항등원 $e$가 되며 이 경우를 *free* action이라 한다. 따라서 free인 경우 항등원 이외의 원소는 x를 x로 유지하지 않는다.\n\n\n```note\nIf $S$ is a set and $G$ is a group that acts on it, the notation $S / G$ (or $G \\backslash S$ ) is used to denote the set of equivalence classes of $S$ under the action of $G$.\n```\n\n\n```note\n In other words, if $G$ does not act transitively on $S$, then it divides it into disjoint equivalence classes called *orbits*\n```\n\n\n이를 보여주는 예제가 바로 $\\mathbb{R}^{n}/SO(n)$ ( or $SO(n)\\backslash  \\mathbb{R}^n$) 이다.  \n\n$\\omega \\in \\mathbb{R}^{3}$의 원소를 $R \\in SO(3)$을 이용하여 다음과 같이 나타낼 수 있다.\n\n$$\n  \\omega^\\prime = R \\omega \\in \\mathbb{R}^3\n$$\n\n이 경우 $\\mathbb{R}^{3}/SO(3)$ 으로 나타낼 수 있다. 많은 책들에서 $\\mathbb{R}^{3}/SO(3)$  로 표기한다. 그러나 이 책에서는 group을 먼저 적는다..  ($SO(n)\\backslash \\mathbb{R}^{n}$), 의미적으로는 같다.\n\n\n### 10.1.5 Cosets\n### 10.1.6 Coset Spaces and Quotient Groups\n### 10.1.7 Double-Coset Decompositions\n### 10.1.8 Mappings Between Groups\n#### Homomorphisms\n#### Isomorphisms\n#### Automorphisms\n### Generating New Mappings from Old Ones\n#### Functions\n### 10.1.9 Products of Groups\n#### Direct Products\n#### Semi-direct Products\n#### Wreath Products\n\n## 10.2 Matrix Lie Groups and Lie Algebras\n### 10.2.1 A Usable Definition of Matrix Lie Groups\n### 10.2.2 Broad Classes of Matrix Lie Groups\n### 10.2.3 The Exponential and Logarithm Maps\n### 10.2.4 The $\\vee$ Operator\n### 10.2.5 The Adjoint Operator $Ad(g)$\n### 10.2.6 The Lie Bracket and $ad(X)$\n### 10.2.7 The Baker–Campbell–Hausdorff Formula\n## 10.3 Change of Basis in a Matrix Lie Algebra\n### 10.3.1 General Change of Basis\n### 10.3.2 Invariance of Functions of Structure Constants\n### 10.3.3 Changes of Basis Due to Adjoint Action\n## 10.4 Inner Products on Matrix Lie Algebras\n### 10.4.1 Calculating Jacobians\n### 10.4.2 Invariant Vector Fields\n## 10.5 Adjoint Matrices and the Killing Form\n### 10.5.1 The Killing Form\n### 10.5.2 The Matrices of $Ad(g)$, $Ad^{\\ast}(g)$, $ad(X)$, and $B(X, Y )$\n### 10.5.3 Relationship Between $ad(X)$ and $B(X, Y )$, and the Structure Constants\n### 10.5.4 Conditions for Unimodularity\n## 10.6 Examples\n### 10.6.1 The Heisenberg Nilpotent Group\n### 10.6.2 The Group of Rigid-Body Motions of the Euclidean Plane, $SE(2)$\n### 10.6.3 The Group $SL(2, \\mathbb{R})$\n### 10.6.4 The Motion Group of the Lobachevsky Plane, $L(2)$\n### 10.6.5 The Lorentz Group, $SO(2,1)$\n### 10.6.6 The Rotation Group, $SO(3)$\n### 10.6.7 The Group $GL(2, \\mathbb{R})$\n### 10.6.8 The Scale-Euclidean Group of the Plane, $SIM(2)$\n### 10.6.9 $SE(3)$, The Group of Rigid-Body Motions\n### 10.6.10 The Weyl–Heisenberg Group and Its Semidirect Product with $SL(2, \\mathbb{R})$\n\n## 10.7 Objects That Are Not Quite Groups\n### Case Study 1:\n### Case Study 2:\n### Case Study 3:\n### Case Study 4:\n### Case Study 5:\n## 10.8 Chapter Summary\n## 10.9 Exercises\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<!-- $$\n\\begin{aligned}\n  & \\phi(x,y) = \\phi \\left(\\sum_{i=1}^n x_ie_i, \\sum_{j=1}^n y_je_j \\right)\n  = \\sum_{i=1}^n \\sum_{j=1}^n x_i y_j \\phi(e_i, e_j) = \\\\\n  & (x_1, \\ldots, x_n) \\left( \\begin{array}{ccc}\n      \\phi(e_1, e_1) & \\cdots & \\phi(e_1, e_n) \\\\\n      \\vdots & \\ddots & \\vdots \\\\\n      \\phi(e_n, e_1) & \\cdots & \\phi(e_n, e_n)\n    \\end{array} \\right)\n  \\left( \\begin{array}{c}\n      y_1 \\\\\n      \\vdots \\\\\n      y_n\n    \\end{array} \\right)\n\\end{aligned}\n$$\n -->\n",
    "tag": "post",
    "summary": "",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 23,
    "title": "aasdf",
    "content": "asdf",
    "tag": "asdf",
    "summary": "asdf",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 24,
    "title": "asdf",
    "content": "asdf",
    "tag": "asdf",
    "summary": "asdf",
    "date": "undefined",
    "password": "sy3253"
  },
  {
    "id": 25,
    "title": "c",
    "content": "cc",
    "tag": "c",
    "summary": "c",
    "date": "undefined",
    "password": "sy3253"
  },
  {
    "id": 26,
    "title": "ff",
    "content": "ff",
    "tag": "ff",
    "summary": "ff",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 27,
    "title": "Kalman Filter & LaTeX Test",
    "content": "# Kalman Filter Basics\r\n\r\nThe Kalman filter is an optimal estimator.\r\n\r\n## State Update Equation\r\n\r\nThe state update is given by:\r\n\r\n$$\r\n\\hat{x}_{k|k} = \\hat{x}_{k|k-1} + K_k (z_k - H_k \\hat{x}_{k|k-1})\r\n$$\r\n\r\nWhere $K_k$ is the Kalman Gain:\r\n\r\n$$\r\nK_k = P_{k|k-1} H_k^T (H_k P_{k|k-1} H_k^T + R_k)^{-1}\r\n$$\r\n\r\n## Markdown Features\r\n- **Bold text**\r\n- *Italic text*\r\n- [Link](https://google.com)\r\n- Code block:\r\n```python\r\ndef predict(x, P, F, Q):\r\n    x = F @ x\r\n    P = F @ P @ F.T + Q\r\n    return x, P\r\n```\r\n",
    "tag": "Sensor",
    "summary": "Testing LaTeX rendering for Kalman Filter equations.",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 28,
    "title": "zsdfasd",
    "content": "ffffffffff",
    "tag": "asdf",
    "summary": "affff",
    "date": "2025-11-26",
    "password": "sy3253"
  },
  {
    "id": 999,
    "title": "Image Test",
    "content": "![Test Image](https://via.placeholder.com/150)",
    "tag": "Test",
    "summary": "Testing image rendering",
    "date": "2025-11-26",
    "password": "admin123"
  }
]